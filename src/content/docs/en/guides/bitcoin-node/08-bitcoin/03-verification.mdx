---
label: Verification
slug: en/guides/bitcoin-node/bitcoin/verification
order: 30
---

import Callout from "@components/mdx/Callout.tsx";

# Verification

We're now going to verify the authenticity of the Bitcoin Core file we downloaded which minimizes the possibility of us running a compromised version of Bitcoin Core.

To verify the authenticity of the file we need to download a checksum file and a signature file for the version of Bitcoin Core we're using. The checksum file is used to check that the file hasn't been corrupted during the download. The signature file is used to check that the hashes in the checksum file haven't been tampered with by ensuring they're the ones created and released by the Bitcoin Core project.

We're also going to download a **proof file** provided by the [OpenTimestamps](https://opentimestamps.org/) protocol. **Timestamps** also known as **proofs-of-existence** prove that some data, e.g., a message existed prior to some point in time. The checksum file is timestamped on the Bitcoin blockchain, so it can be proved that the file existed prior to some point in time.

<Callout client:load type="warning">
  If you download a compromised version of Bitcoin Core, then a loss of funds is possible. Be sure to verify the authenticity of your download.
</Callout>

## Download Verification Files

The checksum and signature files for the latest version of Bitcoin Core can be found on the [Download](https://bitcoincore.org/en/download/) page on the Bitcoin Core website underneath the download files.

Here are links to download the checksum, signature, and timestamp files for Bitcoin Core `25.0` which is the latest version at the time of writing:

- [Bitcoin Core 25.0 SHA256 binary hashes](https://bitcoincore.org/bin/bitcoin-core-25.0/SHA256SUMS)

- [Bitcoin Core 25.0 SHA256 hash signatures](https://bitcoincore.org/bin/bitcoin-core-25.0/SHA256SUMS.asc)

- [Bitcoin Core 25.0 timestamp](https://bitcoincore.org/bin/bitcoin-core-25.0/SHA256SUMS.ots)

If you downloaded a different version of Bitcoin Core, then you can follow these steps to download the corresponding checksum, signature, and timestamp files:

1. Navigate to the Bitcoin Core [Releases](https://bitcoincore.org/en/releases/) page.

2. Click on the version you downloaded

3. Click on the index link, i.e., `https://bitcoincore.org/bin/bitcoin-core-<version>/` which should be underneath the Release Notes section where `<version>` should be replaced with whatever version of Bitcoin Core you downloaded.

4. Download the checksum, signature, and timestamp files which should have the following names `SHA256SUMS`, `SHA256SUMS.asc`, and `SHA256SUMS.ots`, respectively by clicking on each file. Be sure to download them to the same directory as the Bitcoin Core file.

Again, since our node doesn't have a GUI, we're going to download the checksum, signature, and timestamp files using the `wget` command. The files are going to be downloaded to `/tmp` directory which you should have already navigated to if you're using that directory. We'll also be using the `VERSION` variable that we previously set for the current session.

To download the checksum file we can run the following command:

```sh:Download Bitcoin Core Checksums
wget https://bitcoincore.org/bin/bitcoin-core-$VERSION/SHA256SUMS
```

If the download was successful, then there should now be a `SHA256SUMS` file in whatever directory you ran the `wget` command.

To download the signature file we can run the following command:

```sh:Download Bitcoin Core Signatures
wget https://bitcoincore.org/bin/bitcoin-core-$VERSION/SHA256SUMS.asc
```

If the download was successful, then there should now be a `SHA256SUMS.asc` file in whatever directory you ran the `wget` command.

To download the timestamp file we can run the following command:

```sh:Download Bitcoin Core Timestamp
wget https://bitcoincore.org/bin/bitcoin-core-$VERSION/SHA256SUMS.ots
```

If the download was successful, then there should now be a `SHA256SUMS.ots` file in whatever directory you ran the `wget` command.

<Callout client:load type="tip">
  The checksum and signature file names should be `SHA256SUMS` and `SHA256SUMS.asc`, respectively. If they're given different file extensions and/or different names, then the verification process will fail.
</Callout>

Here's how the checksum, signature, and timestamp links provided to the `wget` command can be determined for both the current version of Bitcoin Core as well as any other version.

To determine the checksum and signature links to provide to the `wget` command for the latest version of Bitcoin Core you can use the following steps:

1. Navigate to the Bitcoin Core [Download](https://bitcoincore.org/en/download/) page.

2. Right-click the SHA256 binary hashes file.

3. Copy the link address.

4. Right-click the SHA256 hash signatures file.

5. Copy the link address.

To determine the checksum, signature, and timestamp links to provide to the `wget` command for any version of Bitcoin Core you can use the following steps:

1. Navigate to the Bitcoin Core [Releases](https://bitcoincore.org/en/releases/) page.

2. Click on the version you want to download.

3. Click on the index link, i.e., `https://bitcoincore.org/bin/bitcoin-core-<version>/` which should be located underneath the Release Notes section where `<version>` should be replaced with whatever version of Bitcoin Core you're downloading.

4. Right-click the checksum file which should have the following name `SHA256SUMS`.

5. Copy the link address.

6. Right-click the signature file which should have the following name `SHA256SUMS.asc`.

7. Copy the link address.

8. Right-click the timestamp file which should have the following name `SHA256SUMS.ots`.

7. Copy the link address.

## Required Packages

To perform the verification you’ll need to have `gnupg` installed on the node which should already be installed, but if not here’s how to install it.

### GnuPG

Run the following command to install `gnupg` on the node:

```sh:Install GnuPG on the Node
sudo apt install -y gnupg
```

## Import Bitcoin Core Signing Key(s)

Bitcoin Core releases are signed by multiple individuals each with a unique public key. The signing keys are used to sign the `SHA256SUMS` file, and in order to recognize the validity of the signatures we need to use `gpg` to import at least one of the Bitcoin Core signing keys.

Many Bitcoin Core developer signing keys can be found on GitHub in the Bitcoin Core `guix.sigs` repository in the [builder-keys](https://github.com/bitcoin-core/guix.sigs/tree/main/builder-keys) directory.

If the node had a GUI, then to import a signing key you could navigate to the `builder-keys` directory, click on a signing key you want to download, e.g., `fanquake.gpg`, then click on the Download button to download the raw file to your device.

After downloading the signing key, you could then import the signing key by running the following command:

```sh:Import Signing Key
gpg --import <signing-key>
```

Here `<signing-key>` would be replaced with the file name of the signing key that you downloaded, e.g., `fanquake.gpg`. Also, when running the command above you should be in the same directory where you downloaded the signing key.

After downloading and importing a signing key you would see output that looks similar to:

```sh:Import Signing Key Output
gpg: key 944D35F9AC3DB76A: 20 signatures not checked due to missing keys
gpg: key 944D35F9AC3DB76A: public key "Michael Ford (bitcoin-otc) fanquake@gmail.com" imported
gpg: Total number processed: 1
gpg:               imported: 1
gpg: marginals needed: 3  completes needed: 1  trust model: pgp
gpg: depth: 0  valid:   1  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 1u
gpg: next trustdb check due at 2026-04-20
```

Here we see `imported: 1` which means the signing key was successfully imported. The output may also say the signing key was updated, has new signatures, or remained unchanged if it was previously imported.

Since our node doesn't have a GUI, we're going to download the signing key using the `wget` command.

To download a signing key using Wget we can run the following command:

```sh:Download a Bitcoin Core Signing Key
wget https://raw.githubusercontent.com/bitcoin-core/guix.sigs/main/builder-keys/<signing-key>
```

Here `<signing-key>` should be replaced with the file name of the signing key that you want to download, e.g., `fanquake.gpg`.

To determine the link to provide to the `wget` command to download a signing key you can use the following steps:

1. Navigate to the [builder-keys](https://github.com/bitcoin-core/guix.sigs/tree/main/builder-keys) directory in the Bitcoin Core `guix.sigs` repository

2. Click on the signing key you want to download.

3. Click on the Raw button to display the file contents.

4. Copy the URL in the browser.

<Callout client:load type="tip">
  If the download is taking a while, then you can force Wget to only look for IPv4 addresses using the `--inet4-only` flag, i.e., `wget --inet4-only https://raw.githubusercontent.com/bitcoin-core/guix.sigs/main/builder-keys/<signing-key>`. This prevents Wget from trying to download the file using IPv6 addresses which may time out.
</Callout>

After downloading the signing key using Wget, you can then import the signing key by running the following command:

```sh:Import Signing Key
gpg --import <signing-key>
```

Here `<signing-key>` would be replaced with the file name of the signing key that you downloaded, e.g., `fanquake.gpg`. Also, when running the command above you should be in the same directory where you downloaded the signing key.

After downloading and importing a signing key you would see output that looks similar to:

```sh:Import Signing Key Output
gpg: key 944D35F9AC3DB76A: 20 signatures not checked due to missing keys
gpg: /home/satoshi/.gnupg/trustdb.gpg: trustdb created
gpg: key 944D35F9AC3DB76A: public key "Michael Ford (bitcoin-otc) <fanquake@gmail.com>" imported
gpg: Total number processed: 1
gpg:               imported: 1
gpg: no ultimately trusted keys found
```

Here we see `imported: 1` which means the signing key was successfully imported. The output may also say the signing key was updated, has new signatures, or remained unchanged if it was previously imported.

It's recommended to choose multiple trustworthy individuals from the `builder-keys` directory and import their keys using, e.g., the method we used above. However, that can become tedious since we have to individually download and import each signing key. Also, ideally we would download and import each signing key which makes the process even more tedious.

To get around this we can clone the `guix.sigs` repository and then import all of the signing keys using a single command.

To clone the repository we need to have `git` installed on the node.

We're going to first fetch the information about the latest versions of the packages available for our system by running the following command:

```sh:Update apt
sudo apt update
```

We can now run the following command to install `git` on the node:

```sh:Install Git on the Node
sudo apt install -y git
```

To clone the `guix.sigs` repository we can run the following command:

```sh:Clone guix.sigs Repository
git clone https://github.com/bitcoin-core/guix.sigs
```

We can now run the following command to import all of the signing keys in the `builder-keys` directory:

```sh:Import All Signing Keys
gpg --import guix.sigs/builder-keys/*
```

After downloading and importing all of the signing keys you should see output that looks similar to:

```sh:Import All Signing Keys Output
gpg: key 188CBB2648416AD5: 6 signatures not checked due to missing keys
gpg: key 188CBB2648416AD5: public key ".0xB10C <b10c@b10c.me>" imported
gpg: key 17565732E08E5E41: 29 signatures not checked due to missing keys
gpg: key 17565732E08E5E41: public key "Andrew Chow <andrew@achow101.com>" imported
gpg: key D7CC770B81FD22A8: 2 signatures not checked due to missing keys
gpg: key D7CC770B81FD22A8: public key "Ben Carman <benthecarman@live.com>" imported
gpg: key 1C2491FFEB0EF770: 2 signatures not checked due to missing keys
gpg: key 1C2491FFEB0EF770: public key "Cory Fields <cfields@bitcoinfoundation.org>" imported
gpg: key A5E0907A0380E6C3: public key "CoinForensics (SigningKey) <59567284+coinforensics@users.noreply.github.com>" imported
gpg: key E13FC145CD3F4304: 15 signatures not checked due to missing keys
gpg: key E13FC145CD3F4304: public key "Antoine Poinsot <darosior@protonmail.com>" imported
gpg: key C37B1C1D44C786EE: public key "Duncan Dean <duncangleeddean@gmail.com>" imported
gpg: key 2EBB056FD847F8A7: 12 signatures not checked due to missing keys
gpg: key 2EBB056FD847F8A7: public key "Stephan Oeste (it) <it@oeste.de>" imported
gpg: key 944D35F9AC3DB76A: 18 signatures not checked due to missing keys
gpg: key 944D35F9AC3DB76A: "Michael Ford (bitcoin-otc) <fanquake@gmail.com>" not changed
gpg: key 8F617F1200A6D25C: 8 signatures not checked due to missing keys
gpg: key 8F617F1200A6D25C: public key "Gloria Zhao <gloriazhao@berkeley.edu>" imported
gpg: key 8E4256593F177720: 1 signature not checked due to a missing key
gpg: key 8E4256593F177720: public key "Oliver Gugger <gugger@gmail.com>" imported
gpg: key 410108112E7EA81F: public key "Hennadii Stepanov (GitHub key) <32963518+hebasto@users.noreply.github.com>" imported
gpg: key D11BD4F33F1DB499: public key "jackielove4u <jackielove4u@hotmail.com>" imported
gpg: key 8ADCB558C4F33D65: public key "josibake@protonmail.com <josibake@protonmail.com>" imported
gpg: key 74810B012346C9A6: 104 signatures not checked due to missing keys
gpg: key 74810B012346C9A6: public key "Wladimir J. van der Laan <laanwj@protonmail.com>" imported
gpg: key 747A7AE2FB0FD25B: public key "satsie <staciewaleyko@gmail.com>" imported
gpg: key 860FEB804E669320: 61 signatures not checked due to missing keys
gpg: key 860FEB804E669320: public key "Pieter Wuille <pieter@wuille.net>" imported
gpg: key 57FF9BDBCC301009: 36 signatures not checked due to missing keys
gpg: key 57FF9BDBCC301009: public key "Sjors Provoost <sjors@sprovoost.nl>" imported
gpg: key 476E74C8529A9006: public key "Sebastian van Staa <sebastian.van.staa@gmail.com>" imported
gpg: key 9303B33A305224CB: 15 signatures not checked due to missing keys
gpg: key 9303B33A305224CB: public key "Sebastian Kung (TheCharlatan) <seb.kung@gmail.com>" imported
gpg: key C2371D91CB716EA7: public key "Sebastian Falbesoner (theStack) <sebastian.falbesoner@gmail.com>" imported
gpg: key A7BEB2621678D37D: public key "vertiond <vertion@protonmail.com>" imported
gpg: key 3B8F814A784218F8: public key "Will Clark <will@256k1.dev>" imported
gpg: key 8E3A8F3247DBCBBF: public key "Willy Ko <willyk@syscoin.org>" imported
gpg: Total number processed: 24
gpg:               imported: 23
gpg:              unchanged: 1
gpg: no ultimately trusted keys found
```

## Verify the Checksum File

We're now ready to verify the checksum file is signed by a sufficient number of signing keys that we trust and have imported into our keychain.

To verify the checksum file we can run the following command:

```sh:Verify Checksum File
gpg --verify SHA256SUMS.asc
```

You should see the output that looks similar to the following if the verification was successful:

```sh:Checksum Verification Output
gpg: assuming signed data in 'SHA256SUMS'
gpg: Signature made Thu 25 May 2023 12:39:28 PM CST
gpg:                using RSA key 101598DC823C1B5F9A6624ABA5E0907A0380E6C3
gpg: Good signature from "CoinForensics (SigningKey) <59567284+coinforensics@users.noreply.github.com>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: 1015 98DC 823C 1B5F 9A66  24AB A5E0 907A 0380 E6C3
gpg: Signature made Thu 25 May 2023 10:14:12 AM CST
gpg:                using RSA key F2CFC4ABD0B99D837EEBB7D09B79B45691DB4173
gpg:                issuer "seb.kung@gmail.com"
gpg: Good signature from "Sebastian Kung (TheCharlatan) <seb.kung@gmail.com>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: A8FC 55F3 B04B A314 6F34  92E7 9303 B33A 3052 24CB
     Subkey fingerprint: F2CF C4AB D0B9 9D83 7EEB  B7D0 9B79 B456 91DB 4173
gpg: Signature made Thu 25 May 2023 10:11:37 AM CST
gpg:                using RSA key 152812300785C96444D3334D17565732E08E5E41
gpg:                issuer "andrew@achow101.com"
gpg: Good signature from "Andrew Chow <andrew@achow101.com>" [unknown]
gpg:                 aka "Andrew Chow <achow101@pm.me>" [unknown]
gpg:                 aka "Andrew Chow <github@achow101.com>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: 1528 1230 0785 C964 44D3  334D 1756 5732 E08E 5E41
gpg: Signature made Thu 25 May 2023 08:25:00 PM CST
gpg:                using RSA key 0AD83877C1F0CD1EE9BD660AD7CC770B81FD22A8
gpg:                issuer "benthecarman@live.com"
gpg: Good signature from "Ben Carman <benthecarman@live.com>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: 0AD8 3877 C1F0 CD1E E9BD  660A D7CC 770B 81FD 22A8
gpg: Signature made Thu 25 May 2023 01:13:59 PM CST
gpg:                using RSA key C060A6635913D98A3587D7DB1C2491FFEB0EF770
gpg:                issuer "cfields@bitcoinfoundation.org"
gpg: Good signature from "Cory Fields <cfields@bitcoinfoundation.org>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: C060 A663 5913 D98A 3587  D7DB 1C24 91FF EB0E F770
gpg: Signature made Thu 25 May 2023 10:09:02 AM CST
gpg:                using RSA key CFB16E21C950F67FA95E558F2EEB9F5CC09526C1
gpg:                issuer "fanquake@gmail.com"
gpg: Good signature from "Michael Ford (bitcoin-otc) <fanquake@gmail.com>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: E777 299F C265 DD04 7930  70EB 944D 35F9 AC3D B76A
     Subkey fingerprint: CFB1 6E21 C950 F67F A95E  558F 2EEB 9F5C C095 26C1
gpg: Signature made Fri 26 May 2023 03:51:04 AM CST
gpg:                using RSA key F19F5FF2B0589EC341220045BA03F4DBE0C63FB4
gpg: Good signature from "Gloria Zhao <gloriazhao@berkeley.edu>" [unknown]
gpg:                 aka "Gloria Zhao <gloriajzhao@gmail.com>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: 6B00 2C6E A3F9 1B1B 0DF0  C9BC 8F61 7F12 00A6 D25C
     Subkey fingerprint: F19F 5FF2 B058 9EC3 4122  0045 BA03 F4DB E0C6 3FB4
gpg: Signature made Thu 25 May 2023 10:24:56 AM CST
gpg:                using RSA key F4FC70F07310028424EFC20A8E4256593F177720
gpg:                issuer "gugger@gmail.com"
gpg: Good signature from "Oliver Gugger <gugger@gmail.com>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: F4FC 70F0 7310 0284 24EF  C20A 8E42 5659 3F17 7720
gpg: Signature made Thu 25 May 2023 10:10:42 AM CST
gpg:                using RSA key D1DBF2C4B96F2DEBF4C16654410108112E7EA81F
gpg:                issuer "hebasto@gmail.com"
gpg: Good signature from "Hennadii Stepanov (GitHub key) <32963518+hebasto@users.noreply.github.com>" [unknown]
gpg:                 aka "Hennadii Stepanov (hebasto) <hebasto@gmail.com>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: D1DB F2C4 B96F 2DEB F4C1  6654 4101 0811 2E7E A81F
gpg: Signature made Fri 26 May 2023 01:13:37 AM CST
gpg:                using RSA key 287AE4CA1187C68C08B49CB2D11BD4F33F1DB499
gpg: Good signature from "jackielove4u <jackielove4u@hotmail.com>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: 287A E4CA 1187 C68C 08B4  9CB2 D11B D4F3 3F1D B499
gpg: Signature made Thu 25 May 2023 11:46:27 AM CST
gpg:                using RSA key 9DEAE0DC7063249FB05474681E4AED62986CD25D
gpg: Good signature from "Wladimir J. van der Laan <laanwj@protonmail.com>" [unknown]
gpg:                 aka "Wladimir J. van der Laan <laanwj@gmail.com>" [unknown]
gpg:                 aka "Wladimir J. van der Laan <laanwj@visucore.com>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: 71A3 B167 3540 5025 D447  E8F2 7481 0B01 2346 C9A6
     Subkey fingerprint: 9DEA E0DC 7063 249F B054  7468 1E4A ED62 986C D25D
gpg: Signature made Thu 25 May 2023 10:09:38 AM CST
gpg:                using RSA key 6A8F9C266528E25AEB1D7731C2371D91CB716EA7
gpg:                issuer "sebastian.falbesoner@gmail.com"
gpg: Good signature from "Sebastian Falbesoner (theStack) <sebastian.falbesoner@gmail.com>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: 6A8F 9C26 6528 E25A EB1D  7731 C237 1D91 CB71 6EA7
gpg: Signature made Thu 25 May 2023 10:19:41 AM CST
gpg:                using RSA key 28E72909F1717FE9607754F8A7BEB2621678D37D
gpg:                issuer "vertion@protonmail.com"
gpg: Good signature from "vertiond <vertion@protonmail.com>" [unknown]
gpg:                 aka "vertion <vertion@protonmail.com>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: 28E7 2909 F171 7FE9 6077  54F8 A7BE B262 1678 D37D
```

The command outputs signature checks for each of the public keys that signed the checksums.

Each valid signature will have the following output:

1. A line that shows: `gpg: Good signature from...`, e.g., `gpg: Good signature from "vertiond <vertion@protonmail.com>" [unknown]
`

2. A line displaying `Primary key fingerprint:...`, e.g., `Primary key fingerprint: 28E7 2909 F171 7FE9 6077  54F8 A7BE B262 1678 D37D
`

The output may contain warnings that a public key is not available which means you didn't import all of the keys used to sign the release of Bitcoin Core. As long as you have all of the public keys of signers you trust, this warning can be ignored.

Also, unless you tell GnuPG to trust the key, you’ll see a warning similar to the following:

```sh:GnuPG Trust Warning
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
```

This warning means that the key is not certified by another third party authority. If the downloaded file was a fake, then the signature verification process would fail and you would be warned that the fingerprints don’t match.

When you get a warning like this it’s also good practice to check some or all of the keys against other sources.

E.g., to check Andrew Chow's primary key fingerprint we could navigate to [Andrew Chow's Keybase](https://keybase.io/achow101), click on his public key, i.e., the line that says `1756 5732 E08E 5E41` to view the primary key fingerprint, and then check that it matches the primary key fingerprint we have.

## Verify Bitcoin Core File

We can now verify the Bitcoin Core file we downloaded by recomputing the `SHA256` hash of the file, compare it with the corresponding hash in the `SHA256SUMS` file, and ensure they match exactly by running the following command:

```sh:Verify Bitcoin Core File
sha256sum --ignore-missing --check SHA256SUMS
```

If the verification was successful you should see output similar to the following:

```sh:Bitcoin Core File Verification Output
bitcoin-xx.xx.xx-x86_64-linux-gnu.tar.gz: OK
```

Where the `xx.xx.xx` is replaced by whatever version of Bitcoin Core you're verifying, e.g., `25.0`, and `x86_64-linux-gnu.tar.gz` is replaced by whatever architecture you're using and whatever file type you downloaded.

Any warnings and/or failures in the output can be safely ignored as long as the output displays `OK` after the name of the Bitcoin Core file you're verifying, e.g., `bitcoin-25.0-x86_64-linux-gnu.tar.gz: OK`.

<Callout client:load type="info">
  The `SHA256SUMS` file contains checksums for other architectures supported by Bitcoin Core which we didn't download, e.g., `riscv64`. This is why we're using the `--ignore-missing` flag which allows us to ignore any output associated with any files that are missing.
</Callout>

## Verify Timestamp

We're now going to install the OpenTimestamps client on the node which is a CLI tool that allows us to create and validate timestamp proofs using the OpenTimestamps protocol. The tool also provides timestamping of **GNU Privacy Guard (GPG)** signed git commits as well as verification of timestamps for both git commits and individual files within a git repository.

### Installation

To perform the timestamp verification we need to install the following dependencies some of which may already be installed on the node by running the following command:

```sh:Install OpenTimestamps Dependencies
sudo apt install -y python3 python3-dev python3-pip python3-setuptools python3-wheel
```

We're now going to install [pipx](https://pypa.github.io/pipx/) which is a specialized package installer that's used for installing and running Python applications with CLI entrypoints in isolated environments that are globally accessible on the system. By using pipx we're able to prevent potential dependency conflicts with other Python applications and the node's global Python environment.

We're going to use the prebuilt Debian package from the OS repository to install pipx by running the following command:

```sh:Install pipx
sudo apt install -y pipx
```

We can now install the OpenTimestamps client using pipx which allows us to run the application in an isolated environment that is globally accessible on the node by running the following command:

```sh:Install opentimestamps-client
pipx install opentimestamps-client
```

After the installation completes, you'll see output that looks similar to the following:

```sh:opentimestamps-client Installation Output
  installed package opentimestamps-client 0.7.1, installed using Python 3.11.2
  These apps are now globally available
    - ots
    - ots-git-gpg-wrapper
⚠️  Note: '/home/<username>/.local/bin' is not on your PATH environment
    variable. These apps will not be globally accessible until your
    PATH is updated. Run `pipx ensurepath` to automatically add it, or
    manually modify your PATH in your shell's config file (i.e.
    ~/.bashrc).
done! ✨ 🌟 ✨
```

The output gives a warning saying that the applications we installed, i.e., `ots` and `ots-git-gpg-wrapper` are not globally accessible until our `PATH` is updated to include `/home/<username>/.local/bin` where `<username>` is the username you set during the installation.

The output also mentions we can automatically add `/home/<username>/.local/bin` to the `PATH` by running the following command:

```sh:Automatically Update PATH
pipx ensurepath
```

After updating the `PATH`, you'll see output that looks similar to the following:

```sh:Automatically Update PATH Output
Success! Added /home/<username>/.local/bin to the PATH environment
    variable.

Consider adding shell completions for pipx. Run 'pipx completions' for
instructions.

You will need to open a new terminal or re-login for the PATH changes
to take effect.

Otherwise pipx is ready to go! ✨ 🌟 ✨
```

From the output we see that we need to open a new terminal or re-login for the `PATH` updates to take effect.

To logout of the node we can run the following command:

```sh:Logout
logout
```

To log back into the node we can SSH into the node using the following command:

```sh:SSH into Node using an IP Address and Custom Port
ssh -p <port-number> <username>@<ip-address>
```

Here `<username>` should be replaced with the username you set during the installation, e.g., `satoshi`, `<ip-address>` should be replaced with the IP address of your node, e.g., `192.168.0.100`, and `<port-number>` should be replaced with the port number you set in the `sshd_config` file on the node.

To SSH into my node, I would run the following command:

```sh:SSH into my Node using an IP Address and Custom Port
ssh -p 2222 satoshi@192.168.0.100
```

<Callout client:load type="tip">
  After logging back into your node, be sure to navigate to the `/tmp` directory or whatever directory you downloaded Bitcoin Core and the verification files to.
</Callout>

### Timestamp Information

To get verbose information about the timestamp we can use the `ots` application with the `-v` option and pass the timestamp file, i.e., `SHA256SUMS.ots` to the `info` subcommand:

```sh:Verbose SHA256SUMS.ots Information
ots -v info SHA256SUMS.ots
```

The output should look similar to the following:

```sh:Verbose SHA256SUMS.ots Information Output
File sha256 hash: 74ae008c8c0a60c4b8a773b73d743a74d162ff2c53108be99015c82e33b8d0d4
Timestamp:
append 72e2fb60add0c1c47f4d287c2f2ba11c == 74ae008c8c0a60c4b8a773b73d743a74d162ff2c53108be99015c82e33b8d0d472e2fb60add0c1c47f4d287c2f2ba11c
sha256 == d8fa7ee9db25249eaa04f6a0a84c0871f7c70447620a13e17c83b71748e1e9b6
 -> append 5da5dc579481215f14a0ab716b1a53f8 == d8fa7ee9db25249eaa04f6a0a84c0871f7c70447620a13e17c83b71748e1e9b65da5dc579481215f14a0ab716b1a53f8
    sha256 == 18cf9bf11431e2a64fc4a153de655ef8a1fd3a8c7e15ab725a213436560c1192
    prepend 6470820a == 6470820a18cf9bf11431e2a64fc4a153de655ef8a1fd3a8c7e15ab725a213436560c1192
    append 2cd71141aebb20ac == 6470820a18cf9bf11431e2a64fc4a153de655ef8a1fd3a8c7e15ab725a213436560c11922cd71141aebb20ac
    verify PendingAttestation('https://btc.calendar.catallaxy.com')
 -> append 65097c9d20d054b9667a6986ed1e277b == d8fa7ee9db25249eaa04f6a0a84c0871f7c70447620a13e17c83b71748e1e9b665097c9d20d054b9667a6986ed1e277b
    sha256 == 7fe10b67e2c5a23e8b01b00bf3871b1a08c17793580d32ca0a0d41594bd6e348
    append 8440b9173a842c85e15a270482377820c169364285c90822fedd9e63ca128610 == 7fe10b67e2c5a23e8b01b00bf3871b1a08c17793580d32ca0a0d41594bd6e3488440b9173a842c85e15a270482377820c169364285c90822fedd9e63ca128610
    sha256 == 26400f738d7706de630829cc3f224a2c60f8960b226f2be4dba9f28b8972a1c0
    append 7fa960faabd68bc4680e5d839551f45117dea4cb05e906cffddba4898a264645 == 26400f738d7706de630829cc3f224a2c60f8960b226f2be4dba9f28b8972a1c07fa960faabd68bc4680e5d839551f45117dea4cb05e906cffddba4898a264645
    sha256 == cc018d1fe79a8cc601e5a2662ba343ebe80ca486455847c95d5133e6f5
98503d
    prepend 64708209 == 64708209cc018d1fe79a8cc601e5a2662ba343ebe80ca486455847c95d5133e6f598503d
    append d947a0509bbb7386 == 64708209cc018d1fe79a8cc601e5a2662ba343ebe80ca486455847c95d5133e6f598503dd947a0509bbb7386
    verify PendingAttestation('https://finney.calendar.eternitywall.com')
 -> append 9726f01d70aa1f74ef519451008e692f == d8fa7ee9db25249eaa04f6a0a84c0871f7c70447620a13e17c83b71748e1e9b69726f01d70aa1f74ef519451008e692f
    sha256 == 38d40a1d6ce4a212f127148d1c7585b9b41b81251162099974678bc6f64ffa76
    prepend 64708208 == 6470820838d40a1d6ce4a212f127148d1c7585b9b41b81251162099974678bc6f64ffa76
    append 210a1204b459c0c6 == 6470820838d40a1d6ce4a212f127148d1c7585b9b41b81251162099974678bc6f64ffa76210a1204b459c0c6
    verify PendingAttestation('https://bob.btc.calendar.opentimestamps.org')
 -> append afa753d272a309d371d7323e7490f7a7 == d8fa7ee9db25249eaa04f6a0a84c0871f7c70447620a13e17c83b71748e1e9b6afa753d272a309d371d7323e7490f7a7
    sha256 == 329d1fd1829266f29113526ddf2a4ce3c2f9f8a4939828e009fad4c35364424f
    prepend 5a6edea23a39c032e87f3e7cb54a371bff4b950713ea641847e0928cdd1e0223 == 5a6edea23a39c032e87f3e7cb54a371bff4b950713ea641847e0928cdd1e0223329d1fd1829266f29113526ddf2a4ce3c2f9f8a4939828e009fad4c35364424f
    sha256 == 7bd0edf360295139db7eaff06dd5715143219675fe27368ac54299796d496777
    prepend 64708207 == 647082077bd0edf360295139db7eaff06dd5715143219675fe27368ac54299796d496777
    append 8a30b25bf9cc027b == 647082077bd0edf360295139db7eaff06dd5715143219675fe27368ac54299796d4967778a30b25bf9cc027b
    verify PendingAttestation('https://alice.btc.calendar.opentimestamps.org')
```

The verbose output provides us with the following information about the timestamp:

- The SHA256 hash of the checksum file, i.e., `SHA256SUMS` which can be found on the line that starts with `File sha256 hash`.

- Clarification of the input, output, and operation for each **commitment operation** which are the lines that begin with `sha256`, `append`, and `prepend`.

- The pending attestations, i.e., the retrieval of the rest of the timestamp for the `SHA256SUMS` file from the publically available **calendar servers**. We'll discuss what calendar servers are in more detail below.

A timestamp proof in OpenTimestamps is a list of commitment operations that are applied to the hash of a message in sequence. In our case the message is the `SHA256SUMS` file.

Commitment operations are operations where if the input to the operation changes, then the output also changes. Examples of commitment operations include `append`, `prepend`, and cryptographic hash functions, e.g., `sha256`.

By representing the file we're timestamping using commitment operations it doesn't matter how we create the timestamp as long as we can extract a valid list of commitment operations that the OpenTimestamps protocol supports. This means anyone running the OpenTimestamp protocol can verify the authenticity of the timestamp.

To verify the timestamp proof the commitment operations need to be calculated in the same sequence. The final result then needs to be checked against a message that we already know existed at a certain time.

This is where the Bitcoin blockchain comes into play which we use as a notary, i.e. an official who serves as an impartial witness to the authenticity of some data. In our case the notary is being used to attest that a file existed prior to some point in time.

The Bitcoin blockchain consists of **blocks** which each contain a **block header** along with other fields. The block header includes a field called `nTime` which represents the approximate time that a block was created. The accuracy of `nTime` needed for the block to be considered valid is a complex topic, but it's fair to assume it'll be accurate to within two or three hours and almost certainly within a day.

Since Bitcoin block headers contain a field representing the approximate time that a block was created, we can use the block headers as time attestations, i.e., proof that a notary we trust attested to the fact that some data existed prior to some point in time. If we assume Bitcoin is working as expected, then we know the **80 bytes** that make up a specific block header existed prior to the time contained in the `nTime` field.

E.g., the 80 bytes for the block header for block **791,503** is:

```sh:Block Header for Block 791,503
000000000000000000013d10526472467b0a6e52d00a80eec136112789fc8b1e
```

The approximate time that block 791,503 was created is **May 26th, 2023**.

<Callout client:load type="tip">
 The data for the example block used above as well as for all blocks can be found using a blockchain explorer, e.g., [mempool.space](https://mempool.space/) by searching for the block in the searchbar.
</Callout>

<Callout client:load type="warning">
  Whenever you search a blockchain explorer for data about a specific block, transaction ID, address, etc. you're revealing your IP address as well as other possible PII to the blockchain explorer you're using. Since you're revealing possible PII, it's possbile to link the data you search for to you. E.g., if you're the only one searching the blockchain for a specific address, then it can be assumed that the address is related to you in some way, e.g., belonging to your wallet. This is why it's recommended to use at least Tor when accessing a blockchain explorer being run by someone else or to run your own blockchain explorer which we'll be setting up in a future section.
</Callout>

<Callout client:load type="tip">
  If you're using the Tor Browser you can access mempool.space using the following onion address [mempoolhqx4isw62xs7abwphsq7ldayuidyx2v2oethdhhj6mlo2r6ad.onion](http://mempoolhqx4isw62xs7abwphsq7ldayuidyx2v2oethdhhj6mlo2r6ad.onion/).
</Callout>

From the example above we see that the block header consists of a hash of only 80 bytes which doesn't include the content of the file we're timestamping.

The content of the file we're timestamping isn't directly added to the block header. Also, notice none of the transactions are directly included in the block header. To securely and efficiently store the file we're timestamping as well as the transactions Bitcoin uses another field called `merkleroot`. The value of the merkle root in a block header is calculated by taking all of the transactions included in a block and creating a **merkle tree**.

Here's the value of the merkle root from the block header for block **791,503**:

```sh:Merkle Root for Block 791,503
7f9a264683fd3802563f4529034a2211d9f1ef68658e5345eb636b18a7d1df69
```

<Callout client:load type="tip">
  The value for the merkle root was again determined by using a blockchain explorer, e.g., [mempool.space](https://mempool.space/) by clicking on the Details button after searching for the block.
</Callout>

To create the merkle tree each transaction in a block is hashed using a crytographic hashing function which takes a variable-length input and produces a fixed-length digest, i.e., the output of the hashing algorithm. As long as the hashing function is secure, then it's infeasible to find two inputs that hash to the same output.

After the transactions are hashed, each transaction hash is concatenated to another transaction hash and the output is hashed. Each output hash is then concatenated to another output hash and the resulting output is hashed. This process is repeated until there are no more hashes to concatenate together. The resulting value is the merkle root of the merkle tree.

Since we're using a secure hashing function, if any of the transactions at the bottom of the merkle tree are altered, then every output computed using the altered transaction will be different which ultimately results in a different merkle root.

So, if we take the file we're timestamping, perform commitment operations on it, and then add it to a Bitcoin transaction, then the content of the file must have existed prior to when the block header was created. This is due to the fact that if the content of the file is changed the resulting value of the commitment operations will change. The different value of the commitment operations will then change the transaction hash which changes the merkle root. The different merkle root then changes the block header of the block.

If you take a look at the verbose `SHA256SUMS.ots` information output above, you'll notice there are arrows, i.e., `->`. These arrows indicate the beginning of each path split for the commitment operation trees which make up timestamps.

If we take a look at the output, we see there are four arrows indicating a split into four distinct commitment operation trees after the initial `append` and `sha256` commitment operations.

Timestamps aren't limited to a linear list of operations instead they're trees of operations where the root is the message, the edges are the commitment operations, and the leaves are the attestations.

These commitment operation trees allow multiple calendars and potentially multiple notaries to attest to the timestamp of a message. In the output above the commitment operation trees are used by multiple calendar servers when attesting to the validity of the timestamp.

Here the attestations can be found on the lines beginning with `verify`. The attestations are retrieved from four publically available calendar servers:

- [btc.calendar.catallaxy.com](https://btc.calendar.catallaxy.com)

- [finney.calendar.eternitywall.com](https://finney.calendar.eternitywall.com)

- [bob.btc.calendar.opentimestamps.org](https://bob.btc.calendar.opentimestamps.org)

- [alice.btc.calendar.opentimestamps.org](https://alice.btc.calendar.opentimestamps.org)

Calendar servers are a compromise to having to wait for the underlying Bitcoin transaction to confirm which takes at least 10 minutes on average and can take significantly longer depending on the state of the network. A calendar is a collection of timestamps, and a calendar server provides remote access to a calendar. You can click on the links above to view information about the four publically available calendars used in the timestamping of the checksum file.

The calendar servers work in conjunction with **aggregation servers** which are publically available "meeting points" where anyone can submit a digest to be timestamped by the Bitcoin blockchain.

Here are two publically available aggregation servers:

- [a.pool.opentimestamps.org](https://a.pool.opentimestamps.org/)

- [b.pool.opentimestamps.org](https://b.pool.opentimestamps.org/)

As digests are submitted for aggregation, they're added to a list of pending digests. The list of pending digests is then periodically combined into a single merkle tree, and the root of the merkle tree is then timestamped by adding it to a Bitcoin transaction which is used in the calculation of the merkle root found in a block header. The server then returns the individual timestamp proofs for each submitted digest.

The aggregation servers are efficient since they can combine numerous digests into a single merkle tree that is then timestamped using the Bitcoin blockchain. As opposed to requiring a new Bitcoin transaction for each digest that is submitted which is inefficient and expensive.

While these aggregation servers are centralized, they're essentially trustless. The worst an aggregation server can do is go offline. It cannot create a fake timestamp since it's the Bitcoin blockchain not the aggregation servers that prove the validity of a timestamp.

The aggregation servers allow the timestamping of messages to be more efficient, but they aren't convenient. The aggregation servers rely on the Bitcoin transaction to confirm which as mentioned above takes at least 10 minutes on average and can take significantly longer depending on the state of the network.

This is where the calendar servers are used in conjuntion with the aggregation servers. Instead of waiting for the Bitcoin transaction to confirm, the aggregation servers aggregate all submitted digests in a one second interval into a merkle tree, and the root of the merkle tree is then submitted to a calendar server.

The calendar servers make the following promises:

1. Every merkle root added to the calendar will be timestamped by the Bitcoin blockchain in a reasonable amount of time.

2. Completed merkle root timestamps will be made available to the public and kept indefinitely.

If you take a look at the verbose `SHA256SUMS.ots` information output above, you'll notice the lines starting with `verify` are asking for the rest of the timestamp from the publically available calendar servers.

By using calendar servers timestamps can be quickly and conveniently created, and it's possible for anyone to verify the timestamp later using the Bitcoin blockchian once the timestamp is added to a confirmed Bitcoin transaction.

However, these public calendars are a centralized point of failure, so timestamps that require the assistance of a calendar server are known as **incomplete timestamps**. The mitigations for the centralization risks of calendar servers are described in more detail below.

### SOCKS5 Proxy

Before going over how to verify the timestamp of the `SHA256SUMS` file, we're going to first discuss how to route all of the traffic used with the `ots` application through a SOCKS5 proxy including DNS queries.

To route the traffic through a SOCKS5 proxy the `ots` application provides the `--socks5-proxy` option that can be used when accessing aggregation and calendar servers.

We'll be using default SOCKS proxy port that Tor is running on, i.e., `9050` which we set up in the [Tor](/en/guides/bitcoin-node/privacy/tor) section of the guide.

To ensure Tor is working properly and listening at the default SOCKS proxy port we can run the following command:

```sh:Check Tor Listening Ports
sudo ss -tulpn | grep tor | grep LISTEN
```

If Tor is working properly, then you should see output that looks similar to:

```sh:Tor Listening Ports Success Output
tcp   LISTEN 0      4096       127.0.0.1:9051      0.0.0.0:*    users:(("tor",pid=612,fd=7))
tcp   LISTEN 0      4096       127.0.0.1:9050      0.0.0.0:*    users:(("tor",pid=612,fd=6))
```

From the output we see Tor is listening on default SOCKS proxy prt as well as the control port we enabled, i.e., `9051`.

To route the traffic through a SOCKS5 proxy we can use the `ots` application with the `--socks5-proxy` option and pass the timestamp file or the file we're timestamping to any subcommand that accesses an aggregation or calendar server:

```sh:Using a SOCKS5 Proxy
ots --socks5-proxy <domain:port> <subcommand> <file>
```

Here `<domain:port>` should be replaced with the domain and port the SOCKS5 proxy is running on, e.g., `127.0.0.1:9050`, `<subcommand>` should be replaced with an `ots` subcommand, e.g., `verify`, and `<file>` should be replaced with the file you're using.

<Callout client:load type="warning">
  If you don't use the SOCKS5 proxy, then you'll be leaking your IP address to aggregation and calendar servers when using the `ots` application.
</Callout>

### Timestamp Verification Using Calendars

To verify the timestamp of the `SHA256SUMS` file using the publically available calendars over the SOCKS5 proxy, we can run the following command inside the directory containing the `SHA256SUMS` and `SHA256SUMS.ots` files:

```sh:Verification over SOCKS5 Proxy Using Calendars
ots --socks5-proxy 127.0.0.1:9050 --no-bitcoin verify SHA256SUMS.ots
```

To verify the timestamp of the `SHA256SUMS` file using the publically available calendars without using the SOCKS5 proxy, we can run the following command inside the directory containing the `SHA256SUMS` and `SHA256SUMS.ots` files:

```sh:Verification Using Calendars
ots --no-bitcoin verify SHA256SUMS.ots
```

Here we're using the `--no-bitcoin` option with the `verify` subcommand which disables the Bitcoin blockchain when verifying the timestamp.

By default OpenTimestamps assumes we're running a full or pruned Bitcoin node when verifying timestamps which means we don't need to rely on someone's node or blockchain explorer.

We haven't downloaded the Bitcoin blockchain yet, so we need to rely on other nodes in the network to verify the timestamp. We'll use a blockchain explorer we trust to check that the merkle roots from the output match the merkle roots of the outputted Bitcoin blocks.

<Callout client:load type="tip">
  You can use multiple blockchain explorers when verifying the outputted merkle roots match the merkle roots of the outputted Bitcoin blocks. This will provide some redundancy in case a blockchain explorer has been compromised.
</Callout>

<Callout client:load type="info">
  When verifying the timestamp it may take a while for each calendar to return its attestation, so be patient and let the command finish executing.
</Callout>

The output should look similar to the following:

```sh:Verification Using Calendars Output
Assuming target filename is 'SHA256SUMS'
Got 1 attestation(s) from https://alice.btc.calendar.opentimestamps.org
Got 1 attestation(s) from https://bob.btc.calendar.opentimestamps.org
Got 1 attestation(s) from https://finney.calendar.eternitywall.com
Got 1 attestation(s) from https://btc.calendar.catallaxy.com
Not checking Bitcoin attestation; Bitcoin disabled
To verify manually, check that Bitcoin block 791503 has merkleroot 7f9a264683fd3802563f4529034a2211d9f1ef68658e5345eb636b18a7d1df69
Not checking Bitcoin attestation; Bitcoin disabled
To verify manually, check that Bitcoin block 791517 has merkleroot 6e6ebb62c688864186c399d6e06067126a257d7ee1b184f7033cc4f2615ad740
Not checking Bitcoin attestation; Bitcoin disabled
To verify manually, check that Bitcoin block 791537 has merkleroot b997775f6c830f3ec3b21165c63807d01835773215c71798b580601d64eae088
Not checking Bitcoin attestation; Bitcoin disabled
To verify manually, check that Bitcoin block 791546 has merkleroot 37976f7b29293371911dbc67a4c5d00f198391b70ea7e9dc7d0ce1908cb1e107
```

We'll be using [mempool.space](https://mempool.space/) on our client to search for the blocks and to check the merkle roots match the outputted merkle roots from the output.

<Callout client:load type="tip">
  Remember if you're using the Tor Browser you can access mempool.space using the following onion address [mempoolhqx4isw62xs7abwphsq7ldayuidyx2v2oethdhhj6mlo2r6ad.onion](http://mempoolhqx4isw62xs7abwphsq7ldayuidyx2v2oethdhhj6mlo2r6ad.onion/).
</Callout>

To check the merkle roots we can search for each block by copying and pasting the block number into the search bar and then click on the Details button to view the merkle root.

If the merkle roots match, then we have successully verified the timestamp for the `SHA256SUMS` file.

### Timestamp Verification Using Cache

If we verify the timestamp of the `SHA256SUMS` file again, by running the following command inside the directory containing the `SHA256SUMS` and `SHA256SUMS.ots` files:

```sh:Verification Using Cache
ots --socks5-proxy 127.0.0.1:9050 --no-bitcoin verify SHA256SUMS.ots
```

The output should look similar to the following:

```sh:Verification Using Cache Output
Assuming target filename is 'SHA256SUMS'
Got 4 attestation(s) from cache
Not checking Bitcoin attestation; Bitcoin disabled
To verify manually, check that Bitcoin block 791503 has merkleroot 7f9a264683fd3802563f4529034a2211d9f1ef68658e5345eb636b18a7d1df69
Not checking Bitcoin attestation; Bitcoin disabled
To verify manually, check that Bitcoin block 791517 has merkleroot 6e6ebb62c688864186c399d6e06067126a257d7ee1b184f7033cc4f2615ad740
Not checking Bitcoin attestation; Bitcoin disabled
To verify manually, check that Bitcoin block 791537 has merkleroot b997775f6c830f3ec3b21165c63807d01835773215c71798b580601d64eae088
Not checking Bitcoin attestation; Bitcoin disabled
To verify manually, check that Bitcoin block 791546 has merkleroot 37976f7b29293371911dbc67a4c5d00f198391b70ea7e9dc7d0ce1908cb1e107
```

Notice that we no longer have to wait for each calendar to return its attestation, instead the attestations have been added to a cache which is stated by the following line `Got 4 attestation(s) from cache`.

The cache is located in the following directory `/home/<username>/.cache/ots` where `<username>` is the username you set during the installation.

### Verification with Bitcoin Node

Once we download the Bitcoin blockchain, we'll be able to verify timestamps without relying on other nodes in the network since we'll be able to use our local copy of the blockchain.

To verify a timestamp using our own Bitcoin node over the SOCKS5 proxy we can run the following command inside the directory containing the file that was timestamped and the corresponding timestamp file:

```sh:Verification over SOCKS5 Proxy with Bitcoin Node
ots --socks5-proxy 127.0.0.1:9050 verify <timestamp-file>.ots
```

To verify a timestamp using our own Bitcoin node over without using the SOCKS5 proxy we can run the following command inside the directory containing the file that was timestamped and the corresponding timestamp file:

```sh:Verification with Bitcoin Node
ots verify <timestamp-file>.ots
```

Where `<timestamp-file>` is replaced with the name of the timestamp file you're verifying.

### Upgrade Timestamp

Since our timestamp file requires the assistance of calendar servers, we're using an incomplete timestamp.

We can upgrade the timestamp file to be a **complete timestamp** over the SOCKS5 proxy by running the following command:

```sh:SHA256SUMS.ots Upgrade over SOCKS5 Proxy
ots --socks5-proxy 127.0.0.1:9050 upgrade SHA256SUMS.ots
```

To upgrade the timestamp file to be a complete timestamp without using the SOCKS5 proxy you can run the following command:

```sh:SHA256SUMS.ots Upgrade
ots upgrade SHA256SUMS.ots
```

The output should look similar to the following:

```sh:SHA256SUMS.ots Upgrade Output
Got 4 attestation(s) from cache
Success! Timestamp complete
```

Since we already verified the timestamp using the `verify` subcommand, OpenTimestamps uses the cache to upgrade the timestamp instead of the calendar servers. It's possible to download the complete timestamp proof from the calendar server(s) as well if the cache is empty.

To get verbose information about the complete timestamp we can use the `ots` application with the `-v` option and pass the timestamp file, i.e., `SHA256SUMS.ots` to the `info` subcommand:

```sh:Verbose SHA256SUMS.ots Complete Information
ots -v info SHA256SUMS.ots
```

The output should look similar to the following:

```sh:Verbose SHA256SUMS.ots Complete Information Output
File sha256 hash: 74ae008c8c0a60c4b8a773b73d743a74d162ff2c53108be99015c82e33b8d0d4
Timestamp:
append 72e2fb60add0c1c47f4d287c2f2ba11c == 74ae008c8c0a60c4b8a773b73d743a74d162ff2c53108be99015c82e33b8d0d472e2fb60add0c1c47f4d287c2f2ba11c
sha256 == d8fa7ee9db25249eaa04f6a0a84c0871f7c70447620a13e17c83b71748e1e9b6
 -> append 5da5dc579481215f14a0ab716b1a53f8 == d8fa7ee9db25249eaa04f6a0a84c0871f7c70447620a13e17c83b71748e1e9b65da5dc579481215f14a0ab716b1a53f8
    sha256 == 18cf9bf11431e2a64fc4a153de655ef8a1fd3a8c7e15ab725a213436560c1192
    prepend 6470820a == 6470820a18cf9bf11431e2a64fc4a153de655ef8a1fd3a8c7e15ab725a213436560c1192
    append 2cd71141aebb20ac == 6470820a18cf9bf11431e2a64fc4a153de655ef8a1fd3a8c7e15ab725a213436560c11922cd71141aebb20ac
    verify PendingAttestation('https://btc.calendar.catallaxy.com')
    sha256 == 203bde4ffe539ba6a35324126a6dab5a1510cbb4abfe16552fdaa5618febb77f
    append 7a8ef4aa06f69694a3d08f0e8b680ce84a2545b3dbd0b7141d6f0a85b5b36872 == 203bde4ffe539ba6a35324126a6dab5a1510cbb4abfe16552fdaa5618febb77f7a8ef4aa06f69694a3d08f0e8b680ce84a2545b3dbd0b7141d6f0a85b5b36872
    ...
    prepend 0100000001b09b941daf8358bb5fcd07c2227617a25747b5916ccfc51a91e2530424666ac10000000000fdffffff020ac22200000000001600149cabd1bd271b28fad89b7b2b77b90aeb8b358c3e0000000000000000226a20 == 0100000001b09b941daf8358bb5fcd07c2227617a25747b5916ccfc51a91e2530424666ac10000000000fdffffff020ac22200000000001600149cabd1bd271b28fad89b7b2b77b90aeb8b358c3e0000000000000000226a20dba7e10a08694def4af44864d445c1811db07bf59806438deb0e2cfbe1efcf19
    append f0130c00 == 0100000001b09b941daf8358bb5fcd07c2227617a25747b5916ccfc51a91e2530424666ac10000000000fdffffff020ac22200000000001600149cabd1bd271b28fad89b7b2b77b90aeb8b358c3e0000000000000000226a20dba7e10a08694def4af44864d445c1811db07bf59806438deb0e2cfbe1efcf19f0130c00
    # Transaction id 5107f729d9a19d1c527876ec5aee28be4fd109aa530aade51d321078adfd0195
    sha256 == b1ecfb39dd10a7385b06b183d543acc2c8fb47639a98ed60ce75332d12b1b0c0
    sha256 == 9501fdad7810321de5ad0a53aa09d14fbe28ee5aec7678521c9da1d929f70751
    ...
    sha256 == b9646603caeadddf09bb615ad12f03bb66446ee793a6bacde6ee314f7761b586
    sha256 == 88e0ea641d6080b59817c71532773518d00738c66511b2c33e0f836c5f7797b9
    verify BitcoinBlockHeaderAttestation(791537)
    # Bitcoin block merkle root b997775f6c830f3ec3b21165c63807d01835773215c71798b580601d64eae088
    ...
```

The verbose output provides us with the following information about the complete timestamp:

- The SHA256 hash of the checksum file, i.e., `SHA256SUMS` which can be found on the line that starts with `File sha256 hash`.

- Clarification of the input, output, and operation for each **commitment operation** which are the lines that begin with `sha256`, `append`, and `prepend`.

- The pending attestations, i.e., the retrieval of the rest of the timestamp for the `SHA256SUMS` file from the publically available **calendar servers**.

- The transaction ID associated with the timestamp, i.e., the line starting with `# Transaction id`.

- Verification from the Bitcoin block header attestation using the Bitcoin block header, e.g., `verify BitcoinBlockHeaderAttestation(791537)`.

- The associated Bitcoin block merkle root, i.e., the line starting with `# Bitcoin block merkle root` .

<Callout client:load type="info">
  Here the `...` is being used to suppress the output of the command. If you take a look at the complete output though you'll see the all of the commitment operations, the transaction IDs, the verification from the Bitcoin block header attestations, and the Bitcoin block merkle root for each of the four publically available calendars that were when generating the timestamp file.
</Callout>

### Calendar Server Mitigations

OpenTimestamps provides several mitigations to the risks associated with using calendar servers.

#### Optional Calendar Use

First of all, you don't have to depend on calendar servers when creating a timestamp.

By using the `--wait` option when creating a timestamp. The client will wait until the timestamp is added to a confirmed transaction in the Bitcoin blockchain.

The produced timestamp will have all of the data needed to prove its validity which allows verification to be done completely locally.

To create a complete timestamp using `--wait` our own Bitcoin node we can run the following command inside the directory containing the file that was timestamped and the corresponding timestamp file:

To create a complete timestamp over the SOCKS5 proxy we can use the `ots` application with the `--wait` option and pass the file we're timestamping to the `stamp` subcommand:

```sh:Create a Complete Timestamp over SOCKS5 Proxy
ots --socks5-proxy <domain:port> --wait stamp <file-to-timestamp>
```

To create a complete timestamp over without using the SOCKS5 proxy we can use the `ots` application with the `--wait` option and pass the file we're timestamping to the `stamp` subcommand:

```sh:Create a Complete Timestamp
ots --wait stamp <file-to-timestamp>
```

Where `<file-to-timestamp>` is replaced with the name of the file you're timestamping, and `<domain:port>` should be replaced with the domain and port the SOCKS5 proxy is running on, e.g., `127.0.0.1:9050`.

#### Upgrading

As demonstrated above incomplete timestamps can also be upgraded after they're initially created using the the `ots` application by passing the timestamp file to the `upgrade` subcommand.

Upgrading the timestamp will download the complete timestamp proof which uses the Bitcoin blockchain from the calendar server.

The result of upgrading a timestamp is the same as if you used the `--wait` option when initially creating the timestamp.

To upgrade a timestamp file over the SOCKS5 proxy we can run the following command:

```sh:Upgrade Timestamp over SOCKS5 Proxy
ots --socks5-proxy <domain:port> upgrade <timestamp-file>.ots
```

To upgrade a timestamp file without using the SOCKS5 proxy we can run the following command:

```sh:Upgrade Timestamp
ots upgrade <timestamp-file>.ots
```

Where `<timestamp-file>` is replaced with the name of the timestamp file you're verifying, and `<domain:port>` should be replaced with the domain and port the SOCKS5 proxy is running on, e.g., `127.0.0.1:9050`.

The upgraded timestamps can then be verified using your own Bitcoin node or someone else's node.

#### Redundancy

By default when a timestamp is created it uses multiple calendar servers simultaneously, and the timestamp is only saved if we get a reponse back from the servers.

This redundnacy takes advantage of the fact that timestamps are commitment operation trees, i.e., the paths for the attestations split after some initial commitment operation(s). This means as long as one of the calendars is available the timestamp can be verified since the calendars don't depend on each other to verify the timestamp.

<Callout client:load type="tip">
  It's also possible to use your own calendar servers instead of or in addition to the publically available calendar servers. Any calendar servers that aren't publically known will just be ignored by any clients attempting to verify the timestamp without knowledge of them. The client has a whitelist of calendars that it will automatically connect to.
</Callout>

#### Caching and Mirroring

The OpenTimestamps protocol also keeps a cache of the timestamp data retreived from the calendar servers as demonstrated above when performing the verification a second time.

This means we can use the cache after we initially retreive the attestations from the calendar servers.

As demonstrated above we can also upgrade a timestamp directly from the cache even if the calendar servers aren't available.

