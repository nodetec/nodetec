---
label: Tor
slug: en/guides/bitcoin-node/privacy/tor
order: 10
---

import Callout from "@components/mdx/Callout.tsx";

# Tor

Runnning our own node at a location we control allows us to be a sovereign peer on the Bitcoin network, but if our node isn't configured with privacy in mind, then we're broadcasting to the whole world that someone at that location is using a Bitcoin node which can become problematic.

The main PII we're leaking is the IP address related to the node which can be used to determine your location quite accurately by using a publicly available and free service like [iplocation.net](https://www.iplocation.net/).

To stop leaking the IP address to everyone, we're going to configure our node to use the FOSS communication protocol [Tor](https://www.torproject.org/) which allows us to run the node in a more anonymous way. We can also use Tor to connect to our node from outside of the LAN, i.e., we'll be able to connect to our node from any location using a client that is running Tor and is able to access the Tor network.

## What is Tor

Tor stands for **The Onion Router** and is a communication protocol that uses a network of relays comprised of thousands of volunteer servers known as **Tor relays** to prevent others from being able to easily track, surveil, and censor the websites you visit. The anonymity of the network increases when more independent volunteers run relays and when more users join the network since there will be fewer points of failure and more traffic to analyze.

The term "onion" is used to describe the three layers of encryption that get applied to your traffic when using the network. The network of Tor relays and the layered encryption allows you to communicate online with more anonymity by obfuscating your IP address, location, and online activities.

Tor can also be used to access the so-called **dark web** which is used to describe computer networks that communicate in a more anonymous way by using, e.g., **onion routing** as well as **onion services** formerly known as **hidden services**. The dark web is a subset of the **deep web** which refers to anything on the internet that isn't indexed and, therefore, accessible via a search engine, e.g., medical records, anything behind a paywall, confidential corporate web pages, etc.

By using Tor we'll be able to achieve more anonymity of the traffic associated with our node, e.g., the validation, broadcasting, querying, etc. of transactions.

## What Tor Isn't

Tor isn't a completely decentralized **peer-to-peer (P2P)** communication protocol. It depends on a set of trusted **directory nodes** each controlled by a different organization. These directory nodes manage and keep the state of the network at any given time. Since there are a relatively small number of directory nodes controlled by centralized organizations, it's possible that some or even all of them can become compromised. However, having these multiple organizations does provide a certain amount of redundancy and distribution of trust. These tradeoffs are necssary because if the protocol was completely P2P, then it wouldn't be very usable.

Tor also doesn't hide the IP address and location of the client sending data over the network. It obfuscates and compartmentalizes the IP address and location of the client which means no single entity can easily obtain this information about the client.

Tor provides more anonymity when using the internet; however, it doesn't give you the ability to achieve perfect anonymity. There are weaknesses in the protocol that can be exploited using various attacks. We'll discuss some of these vulnerabilities below.

## Onion Routing

To achieve more anonymous communication Tor uses a technique called onion routing. In an **onion network** data is wrapped in layers of encryption, analogous to the layers of an onion. The encrypted data is transmitted through a series of Tor relays also known as **onion routers**. The number of layers and relays is typically restricted to three because as the number of layers and relays increases the communication speed decreases.

Each relay is responsible for decrypting or "peeling" one layer of encryption which reveals the data's next destination. When the data reaches the final relay in the path it removes the final layer of encryption and sends the decrypted data to the desired destination server. Since the data is decrypted when it reaches the final relay, it's important that the destination server supports a secure communication protocol like HTTPS to avoid an attacker from being able to view the data in transit.

During the transmission of the data the sender is able to remain anonymous because each intermediate relay only knows the IP address of the immediately preceding and following relays, i.e., no relay knows both the origin and the final destination of the data. Only the entry relay knows the IP address of the originator, i.e., the sender of the data, and only the exit relay knows the IP address of the destination server and has access to the decrypted data.

To gain a better understanding of this process, let's break it down into several steps:

1. The user that wants to send the data runs a Tor client on their device.

2. The client obtains a list of active relays from a directory node.

3. The chosen relays are arranged into a path also known as a **chain** or **circuit** through which the data is transmitted. To preserve the anonymity of the sender no relay in a circuit is able to tell how many other relays are in the circuit. Also, any client is allowed to use any relay for any hop in the circuit except with some restrictions on the exit relay. In practice however, most users should and will use the entry relays recommended by the directory nodes. Even with those mitigations in place it's still possible for both the entry and exit relays to determine their position in a circuit which can cause the traffic to be analyzed in a way that can reduce anonymity. The ability for entry and exit relays to determine their positions in a circuit is described in more detail below.

4. The data is encrypted or "wrapped" three times by the Tor client.

5. The data is sent to the first relay, i.e., the entry relay.

6. The first layer of encryption is "peeled" by the entry relay. By "peeling" the first layer of encryption the entry relay determines where to send the data to next and it also knows the IP address of the preceding relay.

7. The entry relay sends the data to the middle relay.

8. The second layer of encryption is "peeled" by the middle relay. By "peeling" the second layer of encryption the middle relay determines where to send the data to next and it also knows the IP address of the preceding relay.

9. The middle relay sends the data to the exit relay.

10. The final layer of encryption is "peeled" by the exit relay. The data is now decrypted, and the exit relay determines where to send the decrypted data and it also knows the IP address of the preceding relay. The exit relay knows the IP address of the middle relay, but it doesn't know the IP address of the entry relay or the originator.

11. The exit relay sends the decrypted data to the destination server which doesn't need to be running Tor to receive the data ideally over a secure communication protocol like HTTPS.

12. To receive a response from the destination server the data is sent back to the exit relay ideally over a secure communication protocol like HTTPS. After receiving the response the exit relay, adds its layer of encryption to the data.

13. The exit relay sends the encrypted data to the middle relay.

14. The middle relay adds its layer of encryption, so the data is "wrapped" in two layers of encryption.

15. The middle relay sends the data to the entry node.

16. The entry node adds its layer of encryption, so the data is "wrapped" in three layers of encryption.

17. The entry node sends the data to the client.

18. The client is able to decrypt all of the layers of encryption to view the decrypted response from the destination server.

As you can see there are quite a number of steps when sending and receiving data through Tor which slows down the connection. The main concern of Tor is to provide users with greater anonymity when using the internet which is why all of these extra steps take place at the cost slowing down the connection.

### How Relay Positions can be Determined

Even though no relay can know for sure how many other relays are in the circuit and relays have the possibility of being used as either an entry, middle, or exit relay in any given circuit, the entry and exit relays can still determine their position in a circuit. An entry relay can determine its position in a circuit by, e.g., analyzing the incoming IP address and determining that it's not the IP address of a relay being used in the network which means it's most likely a client's IP address. Also, client's don't have long-term identities like relays do which also means it's more likely the IP address belongs to a client. The exit relay can perfom a similar analysis on the IP address of the destination server. The exit relay can also just look at the data and see that it's decrypted which means it's the final relay in a circuit.

## Circuit Updates

Tor reuses the same circuit for new TCP streams for 10 minutes assuming the circuit is functioning properly. If the circuit fails for some reason, then Tor will switch to a new circuit immediately. However, a single TCP stream, e.g., a long Internet Relay Chat (IRC) connection will use the same circuit indefinitely. These individual streams aren't rotated from one circuit to the next since it gives an adversary with a partial view of the network more chances over time to link you to your destination as opposed to just one chance.

When these circuits are updated the entry relay also known as a **guard node** isn't necessarily updated. A guard node is a privileged node since it sees the actual IP address of your client. Guard nodes must be fast and stable which means they must have a high uptime as well as good bandwidth. These requirements can make it more difficult for a regular user to run one, and there is no way for Tor to prevent large companies, governments, etc. from registering a large number of guard nodes.

When a Tor client starts up for the first time it will choose a small and random set of guard nodes, and they will be updated every 2-3 months. This technique provides more protection against a known anonymity-breaking attack. It minimizes the probability of an attacker that controls a certain fraction of the network from being able to easily observe a fraction of every user's traffic. If the guard nodes aren't compromised, then the user's circuits will also not be compromised. If the guard node is compromised, then the attacker will know the IP address of your client. However, the attacker doesn't necessarily have control of the other relays in circuit which are updated on a more frequent basis.

<Callout client:load type="info">
  If you're interested in learning more about the rationale behind how guard nodes are selected, then you can take a look at the [proposal](https://github.com/torproject/torspec/blob/main/proposals/271-another-guard-selection.txt).
</Callout>

## Onion Services

Onion services are services provided by servers that can only be accessed over Tor. Running an onion service provides all of the secuirty benefits of HTTPS along with the added security and privacy benefits of using the Tor network.

The IP address of an onion service is protected since onion services are an overlay network on top of TCP/IP, so IP addresses aren't even used in the protocol.

Onion services provide **end-to-end (E2E) authentication** as well because when a user accesses a particular onion service they know the content they're seeing can only come from the specified onion service and not from some impersonator. This is in contrast to when a user normally accesses a site since a **man-in-the-middle (MITM)** attack is possible which can reroute the user to some other site.

Onion services also encrypt the traffic sent between the client and the onion service.

Finally, onion services can **punch-through** firewalls or routers that are using **Network Address Translation (NAT)**. This means if you're connected to a network that is filtered and are unable to open ports on the firewall you can use an onion service to bypass it.

To be able to connect to the onion service without using an IP address we need to use the onion address of an onion service which will look similar to this:

```sh:Onion Address
vww6ybal4bd7szmgncyruucpgfkqahzddi37ktceo3ah7ngmcopnpyyd.onion
```

The onion address is the identity public key of a specific onion service, and it allows us to achieve the security and privacy benefits we mentioned above.

To establish the connection the client introduces itself to the onion service over the Tor network using the onion address of the onion service. A **rendezvous point** is then set up between the client and the onion service over the Tor network.

The onion address for an onion service can be found on a public website, from a friend, and if you're using your own onion service it will be generated by you.

We'll be setting up an onion service on our node and generating an onion address which will allow us to SSH into the node from outside of our LAN over the Tor network using a client that is running Tor and connected to the Tor network.

<Callout client:load type="info">
  If you're interested in a detailed breakdown of how the onion service protocol works, then take a look at [How Do Onion Services Work?](https://community.torproject.org/onion-services/overview/).
</Callout>

## Tor, Tor Browser, and Tor Browser Launcher

We're now going to discuss the differences between Tor, Tor Browser, and Tor Browser Launcher.

Tor also as known as [little-t-tor](https://support.torproject.org/little-t-tor/) is the core of the Tor Project's software and acts as a **Socket Secure (SOCKS)** proxy which allows a user to achieve more anonymity online using techniques like the ones we described above, i.e. onion routing and onion services. Little-t-tor gets installed as a system-wide daemon, and to configure it you need to edit the `torrc` file which should be located in the `/etc/tor` directory if you're using Debian.

[Tor Browser](https://support.torproject.org/tbb/) is a modified version of [Firefox](https://www.mozilla.org/en-US/firefox/new/) specifically designed for use with Tor that includes enhanced security and privacy features. It's not recommended to install any additional add-ons or plugins with the Tor Browser since they may bypass Tor and compromise security and privacy.

Tor Browser comes with **HTTPS-Only Mode** which forces all connections to websites to use a secure encrypted connection, i.e., HTTPS, **NoScript** which is a browser extension that allows JavaScript and other potentially harmful content to be executed only by trusted websites of your choice, and other patches to enhance security and privacy.

Tor Browser will also block the usage of browser plugins like Flash, RealPlayer, QuickTime, etc. since they can be manipulated into revealing your IP address. You also shouldn't **torrent** over Tor since torrent file-sharing applications can reveal the actual IP address of your client by ignoring proxy settings and making direct connections even when they're told to use Tor and by sending your actual IP address within requests used by the torrent application. Take a look at the [Most Frequently Asked Questions](https://support.torproject.org/faq/) to learn more about the Tor Browser and best practices.

[Tor Browser Launcher](https://github.com/micahflee/torbrowser-launcher) is supposed to make Tor Browser easier to install for GNU/Linux users. The package is `torbrowser-launcher` and can be installed using your Linux distribution's package manager.

Tor Browser Launcher will download and install the most recent version of Tor Browser for your computer's architecture or launch Tor Browser if it's already installed. The launcher will check if a new version of Tor Browser is available and will automatically download and update the browser if there is a new version. The launcher verifies the Tor Browser signature which ensures the downloaded version was signed by the Tor developers and not tampered with. It also adds Tor Browser and Tor Browser Launcher as desktop entries to your desktop environment.

## Installation

We're going to install Tor on the node using the [prebuilt Debian package from the Tor repository](https://deb.torproject.org/) which is maintained by the Tor Project which should always provide the latest stable version of Tor. There is also a prebuilt Debian package from the OS repository that provides the **Long-term support (LTS)** version of Tor, but it might not always provide the latest stable version of Tor. Therefore, it's recommended to install Tor from the Tor repository.

<Callout client:load type="tip">
  If you followed along with the [Tor Installation](/en/guides/bitcoin-node/operating-system/updates#tor-installation) section of the guide, then Tor should already be installed on the node and you can skip this section. It's also recommended to follow the [Updates](/en/guides/bitcoin-node/operating-system/updates) section of the guide to learn about OS updates and to configure the OS updates to be done privately and securely.
</Callout>

### Determine Architecture

Before installing Tor, we need to first determine the node's architecture which we can do by running the following command:

```sh:Determine Architecture
dpkg --print-architecture
```

The Tor repository offers `amd64` and `arm64` binaries. If the command outputs a different architecture, then your node is using an architecture that isn't supported by the Tor repository.

<Callout client:load type="tip">
  If your node is using an unsupported architecture, then you can try installing Tor using a prebuilt Debian package from the OS repository or by [installing Tor from source](https://community.torproject.org/onion-services/setup/install/#installing-tor-from-source).
</Callout>

### Configure apt to Use Tor Repository

We're now going to create a file named `tor.list` in the `/etc/apt/sources.list.d` directory and configure `apt` to use the latest stable version of Tor.

To create and open the file we can run the following command:

```sh:Create tor.list File
sudo nano /etc/apt/sources.list.d/tor.list
```

We're now going to configure `apt` to use the latest stable version of Tor from the Tor repository by adding the following lines to the `tor.list` file:

```sh:Configure apt to Use Tor Repository
deb     [signed-by=/usr/share/keyrings/tor-archive-keyring.gpg] https://deb.torproject.org/torproject.org <distribution> main
deb-src [signed-by=/usr/share/keyrings/tor-archive-keyring.gpg] https://deb.torproject.org/torproject.org <distribution> main
```

Be sure to replace `<distribution>` with the Debian codename which can be found by running the following command:

```sh:Determine Codename
lsb_release -c
```

The output should look similar to:

```sh:Codename Output
No LSB modules are available.
Codename:	bookworm
```

Here we replace `<distribution>` with the codename `bookworm`.

<Callout client:load type="tip">
  HTTPS support has been implemented in the `apt` package since version `1.5`. Therefore, unless you're using Debian 9 (Stretch) or an older release the `apt-transport-https` package no longer needs to be installed. If you're using an older release of Debian you can install the package using `sudo apt install -y apt-transport-https`. If you installed the package and no longer need it, then you can remove it by running the following command `sudo apt remove apt-transport-https --purge`.
</Callout>

### Import Tor Project Signing Key

Before we can import the Tor Project signing key, we need to first temporarily enable the `root` user by running the following command:

```sh:Temporarily Enable the root User
sudo -i
```

If we don't temporarily enable the `root` user, then we'll get a `Permission denied` error when attempting to import the Tor project signing key.

To import the signing key we can run the following command:

```sh:Import Tor Project Signing Key
sudo wget -qO- https://deb.torproject.org/torproject.org/A3C4F0F979CAA22CDBA8F512EE8CBC9E886DDD89.asc | gpg --dearmor | tee /usr/share/keyrings/tor-archive-keyring.gpg >/dev/null
```

After importing the signing key, we can disable the `root` user again by logging out of the session by running the command:

```sh:Exit Session
exit
```

### Update apt

We're now going to fetch the information about the latest versions of the packages available for our system by running the following command:

```sh:Update apt
sudo apt update
```

### Install Tor

After running the above command, we're now able to install the latest stable version of Tor from the Tor repository along with the `deb.torproject.org-keyring` package which is used to keep the Tor Project signing key current by running the following command:

```sh:Install tor and deb.torproject.org-keyring
sudo apt install -y tor deb.torproject.org-keyring
```

## Check Version

After installing Tor, we can check the version by running the following command:

```sh:Check Version
tor --version
```

The output should look similar to:

```sh:Version Output
Aug 25 22:57:52.822 [warn] Tor was compiled with zstd 1.5.2, but is running with zstd 1.5.4. For safety, we'll avoid using advanced zstd functionality.
Tor version 0.4.7.13.
Tor is running on Linux with Libevent 2.1.12-stable, OpenSSL 3.0.9, Zlib 1.2.13, Liblzma 5.4.1, Libzstd 1.5.4 and Glibc 2.36 as libc.
Tor compiled with GCC version 12.2.0
```

If we take a look at the line starting with `Tor version`, then we see the Tor version is `0.4.7.13`.

## Check Tor Status

To check the `status` of Tor run the following command:

```sh:Check Tor Status
sudo systemctl status tor
```

The output should look similar to:

```sh:Tor Status Output
● tor.service - Anonymizing overlay network for TCP (multi-instance-master)
     Loaded: loaded (/lib/systemd/system/tor.service; enabled; preset: enabled)
     Active: active (exited) since Fri 2023-08-25 22:49:42 CST; 43min ago
   Main PID: 2171 (code=exited, status=0/SUCCESS)
        CPU: 1ms
```

From the output of the command we’re able to determine the following about Tor:

- If it's running

- If it's set to automatically start on boot

### Check if Tor is Running

If we look at the following line:

```sh:Check if Tor is Running
Active: active (exited)
```

Then we see that Tor is currently running since the status shows `active (exited)`.

If you see `inactive (dead)`, then Tor isn't running.

### Check if Tor is Enabled

If we look at the following line:

```sh:Check if Tor is Enabled
Loaded: loaded (/lib/systemd/system/tor.service; enabled; preset: enabled)
```

Then we see that Tor is set to automatically start on boot since the service is `enabled`.

If you see `disabled`, then Tor isn't set to automatically start on boot.

## Enable Tor

If Tor isn't enabled to automatically start on boot, then run the following command:

```sh:Enable Tor
sudo systemctl enable tor
```

## Disable Tor

If you want to disable Tor from automatically starting on boot, then run the following command:

```sh:Disable Tor
sudo systemctl disable tor
```

## Start Tor

If Tor isn’t running, then run the following command to start the service:

```sh:Start Tor
sudo systemctl start tor
```

## Stop Tor

If you want to stop Tor, then run the following command:

```sh:Stop Tor
sudo systemctl stop tor
```

## Reload Tor

We can also load configuration updates without performing a complete reboot of Tor by running the following command:

```sh:Reload Tor
sudo systemctl reload tor
```

## Restart Tor

If you want to restart Tor which completely stops then starts the service, then you can run the following command:

```sh:Restart Tor
sudo systemctl restart tor
```

## Use apt Tor Repository Over Tor

When we installed Tor by configuring `apt` to use the latest stable version of Tor instead of using the prebuilt Debian package from the OS repository we used HTTPS connections in the `tor.list` file which we created in the `/etc/apt/sources.list.d` directory.

To use APT with the Tor network with HTTP or HTTPS connections we need to install `apt-transport-tor`. After installing `apt-transport-tor`, we can then configure the `apt` Tor repository to use the Tor network as opposed to just using HTTPS connections.

### Install apt-transport-tor

After installing Tor and checking that it's enabled and running, we can install `apt-transport-tor`.

<Callout client:load type="tip">
  To install `apt-transport-tor` on the node you may be using unencrypted HTTP connections with the repositories in the `/etc/apt/sources.list` file. It's recommended to first configure APT to use HTTPS connections instead which will encrypt the communication between the node and the server you're connecting to. If you haven't already, check out the [Configure HTTPS](/en/guides/bitcoin-node/operating-system/updates#configure-https) section which goes over how to configure APT to use HTTPS connections.
</Callout>

We're now going to fetch the information about the latest versions of the packages available for our system by running the following command:

```sh:Update apt
sudo apt update
```

After running the above command, we're now able to install `apt-transport-tor` by running the following command:

```sh:Install apt-transport-tor
sudo apt install -y apt-transport-tor
```

<Callout client:load type="info">
  Instead of using `apt-transport-tor` you can also force traffic over Tor by using transparent proxying using `iptables` or its successor `nftables` which are maintained by the [netfilter.org project](https://www.netfilter.org/). This method allows you to use onion addresses for APT repositories in the `sources.list` file as if they're standard HTTP addresses, and also has the added benefit of not relying on the installation of another package. Another method is to use an HTTP proxy, e.g., [Privoxy](https://www.privoxy.org/) and enable APT HTTP proxy support.
</Callout>

Now that we have installed `apt-transport-tor` we can also configure the Tor repository to use `tor+https` or `tor+http` with onion addresses.

To open the `tor.list` file we can run the following command:

```sh:Open tor.list File
sudo nano /etc/apt/sources.list.d/tor.list
```

#### tor+https

To configure APT to use HTTPS connections over the Tor network for the Tor repository we can edit the `tor.list` file as follows:

```sh:tor.list File Using HTTPS Over Tor
deb     [signed-by=/usr/share/keyrings/tor-archive-keyring.gpg] tor+https://deb.torproject.org/torproject.org <distribution> main
deb-src [signed-by=/usr/share/keyrings/tor-archive-keyring.gpg] tor+https://deb.torproject.org/torproject.org <distribution> main
```

Here we edited the `tor.list` file to use the HTTPS connections over the Tor network to the `/torproject.org` archive repository provided by `deb.torproject.org`.

Be sure to replace `<distribution>` with, e.g., the Debian codename.

##### Update apt

We're now going to fetch the information about the latest versions of the packages available for our system using the HTTPS over Tor connections we just configured by running the following command:

```sh:Update apt
sudo apt update
```

#### tor+http with Onion Addresses

To configure APT to use HTTP connections over the Tor network using onion addresses which is the most private and secure method we can edit the `tor.list` file as follows:

```sh:tor.list File Using HTTP Over Tor Using Onion Addresses
deb     [signed-by=/usr/share/keyrings/tor-archive-keyring.gpg] tor+http://apow7mjfryruh65chtdydfmqfpj5btws7nbocgtaovhvezgccyjazpqd.onion/torproject.org <distribution> main
deb-src [signed-by=/usr/share/keyrings/tor-archive-keyring.gpg] tor+http://apow7mjfryruh65chtdydfmqfpj5btws7nbocgtaovhvezgccyjazpqd.onion/torproject.org <distribution> main
```

Here we edited the `tor.list` file to use the HTTP connections over the Tor network using onion addresses to the `/torproject.org` archive repository provided by `apow7mjfryruh65chtdydfmqfpj5btws7nbocgtaovhvezgccyjazpqd.onion` which is the onion address for `deb.torproject.org`:

Be sure to replace `<distribution>` with, e.g., the Debian codename.

##### Update apt

We're now going to fetch the information about the latest versions of the packages available for our system using the onion addresses we just configured by running the following command:

```sh:Update apt
sudo apt update
```

## Configuration

We're now going to configure Tor to accept instructions with proper authentication through its control port. By enabling Tor to accept these instructions we'll be able to set up Bitcoin Core to directly communicate with the Tor daemon which will allow us to route all of the Bitcoin Core traffic through the Tor network.

To configure Tor to accept instructions with proper authentication through its control port we need to first open the Tor configuration file, i.e., `torrc` which is located in the `/etc/tor` directory by running the following command:

```sh:Open torrc
sudo nano /etc/tor/torrc
```

After opening the file, you should see a section that looks similar to:

```sh:Disabled Conrtol Port for Local Connections
## The port on which Tor will listen for local connections from Tor
## controller applications, as documented in control-spec.txt.
#ControlPort 9051
## If you enable the controlport, be sure to enable one of these
## authentication methods, to prevent attackers from accessing it.
#HashedControlPassword 16:872860B76453A77D60CA2BB8C1A7042072093276A3D701AD684053EC4C
#CookieAuthentication 1
```

From the section above we can see that if we uncomment the line `#ControlPort 9051`, then we'll enable the control port used by Tor when listening for local connections from Tor controller applications like Bitcoin Core.

By enabling the control port we're giving low-level access to the Tor daemon which allows applications to change and monitor Tor, modify the Tor configuration while Tor is running, and to get details about the Tor network status and circuits.

If we take a look at the next line, then we can see that it's recommended to enable at least one of the authentication methods below to prevent attackers from being able to access the control port we're enabling. If we don't set an authentication method, then Tor trusts any local user that connects to the control port. We have the option of restricting access to the control port using **cookie authentication**, a **control password**, or both.

We're going to enable the cookie authentication method by uncommenting the line `#CookieAuthentication 1` and by adding the following lines to the file:

```sh:Enabled Conrtol Port for Local Connections
## The port on which Tor will listen for local connections from Tor
## controller applications, as documented in control-spec.txt.
ControlPort 9051
## If you enable the controlport, be sure to enable one of these
## authentication methods, to prevent attackers from accessing it.
#HashedControlPassword 16:872860B76453A77D60CA2BB8C1A7042072093276A3D701AD684053EC4C
CookieAuthentication 1
CookieAuthFileGroupReadable 1
DataDirectoryGroupReadable 1
```

We can now save and exit the file.

Here's a description of what each update does:

- `CookieAuthentication`: If this option is set to `0` which is the default value, then cookie authentication is disabled. If the option is set to `1`, then cookie authentication is enabled which means Tor will write a cookie file named `control_auth_cookie` into the default Tor data directory, i.e., `/var/lib/tor` unless we specify a different directory and file name using the `CookieAuthFile` option. By enabling cookie authentication access to the control port is restricted by file permissions that are set on the cookie file and on the Tor data directory. The controller must demonstrate that it has the proper file permissions to access the cookie file which is used to authenticate the user.

- `CookieAuthFileGroupReadable`: If this option is set to `0` which is the default value, then the file system group, i.e., `debian-tor` isn't allowed to read the authentication cookie file. If the option is set to `1`, then the cookie file is readable by the default **group identifier (GID)** which is a numeric value used to represent a specific group, i.e., `debian-tor`.

- `DataDirectoryGroupReadable`: If this option is set to `0` which is the default value, then the file system group associated with the Tor data directory, i.e., `debian-tor` isn't allowed to read the Tor data directory. If the option is set to `1`, then the Tor data directory is readable by the default GID. The Tor data directory is specified by the `DataDirectory` option, and the default value for Debian is `/var/lib/tor`.

<Callout client:load type="tip">
  By setting the `DataDirectoryGroupReadable` to `1` we're also setting the `CacheDirectoryGroupReadable` to `1` since it uses the value of `DataDirectoryGroupReadable` when the `CacheDirectory` and `DataDirectory` options are the same value which they are by default.
</Callout>

To apply the configuration updates we made, we can reload Tor by running the following command:

```sh:Reload Tor
sudo systemctl reload tor
```

<Callout client:load type="info">
  If you're interested in learning about more command line options, configuration file formatting, configuration options, etc., then you can view the Tor man page by running the following command `man tor`.
</Callout>

To ensure Tor is working properly and listening at the default SOCKS proxy port, i.e., `9050` and at the control port we enabled, i.e., `9051` we can run the following command:

```sh:Check Tor Listening Ports
sudo ss -tulpn | grep tor | grep LISTEN
```

If Tor is working properly, then you should see output that looks similar to:

```sh:Tor Listening Ports Success Output
tcp   LISTEN 0      4096       127.0.0.1:9050      0.0.0.0:*    users:(("tor",pid=610,fd=6))
tcp   LISTEN 0      4096       127.0.0.1:9051      0.0.0.0:*    users:(("tor",pid=610,fd=7))
```

To view real time updates and output logs for Tor we can use the `journalctl` utility which allows us to access and manipulate the data collected and managed by the **systemd** logging system **journal** by running the following command:

```sh:View Tor Journal Logs
sudo journalctl -f -u tor@default
```

<Callout client:load type="warning">
  Not all of the network traffic is currently configured to use the Tor network; however, we have the basic configuration set up which will allow us to configure sensitive applications like Bitcoin Core to use it. To route all of the Bitcoin Core traffic over the Tor newtork we're going to create a sepatate user with the name `bitcoin` for security reasons and add the user to the `debian-tor` group which will allow Bitcoin Core to access the Tor daemon.
</Callout>

## SSH over Tor

We’re now going to set up an onion service on our node and generate an onion address. This will allow us to SSH into the node from outside of our LAN over the Tor network using a client that is running Tor and connected to the Tor network.

### Node

To start we're going to configure an onion service on the node and generate an onion address which the client will use to SSH into the node.

To configure an onion service on the node and generate an onion address we need to first open the Tor configuration file, i.e., `torrc` which is located in the `/etc/tor` directory by running the following command:

```sh:Open torrc
sudo nano /etc/tor/torrc
```

After opening the file, you should see a section that looks similar to:

```sh:Onion Service Section
############### This section is just for location-hidden services ###

## Once you have configured a hidden service, you can look at the
## contents of the file ".../hidden_service/hostname" for the address
## to tell people.
##
## HiddenServicePort x y:z says to redirect requests on port x to the
## address y:z.

#HiddenServiceDir /var/lib/tor/hidden_service/
#HiddenServicePort 80 127.0.0.1:80

#HiddenServiceDir /var/lib/tor/other_hidden_service/
#HiddenServicePort 80 127.0.0.1:80
#HiddenServicePort 22 127.0.0.1:22
```

We're going to enable an onion service for SSH by adding the following lines to the file:

```sh:SSH Onion Service
############### This section is just for location-hidden services ###

## Once you have configured a hidden service, you can look at the
## contents of the file ".../hidden_service/hostname" for the address
## to tell people.
##
## HiddenServicePort x y:z says to redirect requests on port x to the
## address y:z.

#HiddenServiceDir /var/lib/tor/hidden_service/
#HiddenServicePort 80 127.0.0.1:80

#HiddenServiceDir /var/lib/tor/other_hidden_service/
#HiddenServicePort 80 127.0.0.1:80
#HiddenServicePort 22 127.0.0.1:22

# SSH Server Onion Service
HiddenServiceDir /var/lib/tor/hidden_service_sshd/
HiddenServicePort 2222 127.0.0.1:2222
```

We can now save and exit the file.

Here's a description of what each update does:

- `HiddenServiceDir`: This option specifies where to store data files for an onion service. These data files include the hostname of the onion service, i.e., the onion address, the public key and private key associated with the onion service, and a directory used to store a list of authorized clients. If you want to use multiple onion services, then you can specify this option multiple times. If the specified directory doesn't exist, then Tor will create it. We're storing the SSH onion service in a directory named `hidden_service_sshd` which is placed inside of the Tor data directory, i.e., `/var/lib/tor`.

- `HiddenServicePort`: This option configures a virtual port, i.e., `VIRTPORT` for an onion service using the following format `VIRTPORT TARGET`. This option tells the onion service to listen on the virtual port and redirect the traffic to the target. If you're using multiple onion services, then you can use this option multiple times where the option applies to the service using the most recent `HiddenServiceDir` value. By default this option maps the virtual port to the same port on `127.0.0.1` over TCP. It's possible to override the target port, address, or both by specifying a port, address, address:port, or unix:path. You can also have multiple lines with the same `VIRTPORT`, and when a user connects to that `VIRTPORT` one of the `TARGETs` from those lines will be randomly selected. We're setting the `VIRTPORT` to be `2222` and the `TARGET` to be `127.0.0.1:2222` since we previously configured the SSH server to listen on port `2222`. If you're using a different listening port for SSH, then be sure to update the port accordingly.

To enable the onion service, we can reload Tor by running the following command:

```sh:Reload Tor
sudo systemctl reload tor
```

To get the onion address which we'll be using to remotely login to the node from our client we can run the following command:

```sh:Display Onion Address
sudo cat /var/lib/tor/hidden_service_sshd/hostname
```

Here we're displaying the content of the `hostname` file, i.e., the onion address.

<Callout client:load type="warning">
  The `hidden_service_sshd` directory also contains the the public and private keys associated with the onion service which need to be kept private. If the keys are leaked, then other people can impersonate the onion service which means it's now compromised, useless, and dangerous to visit. It's also important to note that the onion service we configured is readable by anyone who knows or discovers the address, so it's important to keep the onion address private as well. To prevent anyone from being able to access the onion service we can configure it to require authentication, so only users with a private key will be able to access the service.
</Callout>

<Callout client:load type="tip">
  As mentioned in a previous section, you can use a FOSS password mananger like [KeePass](https://keepass.info/) or [Bitwarden](https://bitwarden.com/) to generate and store your passwords/passphrases as well as the onion address.
</Callout>

If you successfully configured the onion servivce and generated the onion address, then the output should look similar to:

```sh:Onion Address
rtc5bqxmswgjng5yutevxiykautzo2dc4qltme5kkitjhw7kbfimrlad.onion
```

### Client

We're now going to install Tor on the client, so we can use the onion address we generated to login to the node using SSH. Using SSH over Tor varies depending on the client and OS being used. We'll demonstrate how to use SSH over Tor on some common Linux distributions using [torsocks](https://gitlab.torproject.org/tpo/core/torsocks/).

#### Install Tor

We need to first make sure Tor is installed on the client.

If your client is running Debian/Ubuntu, then you can use the same [Installation](/en/guides/bitcoin-node/operating-system/installation) method we used above.

If your client is running Arch, then you can run the following command to install Tor:

```sh:Arch
sudo pacman -S tor
```

After installing Tor, we can check the status by running the following command:

```sh:Check Tor Status
sudo systemctl status tor
```

If Tor isn't enabled, then we can run the following command:

```sh:Enable Tor
sudo systemctl enable tor
```

If Tor isn’t running, then we can run the following command to start the service:

```sh:Start Tor
sudo systemctl start tor
```

#### Torsocks

Torsocks is a FOSS library for intercepting outgoing network connections and redirecting them through the Tor SOCKS proxy. It allows you to use most applications in a safe way with Tor. It also ensures that **Domain Name System (DNS)** requests are handled safely and explicitly rejects any traffic other than TCP from the application that you're using.

The library overloads the internet communication **standard C library (libc)** function calls, e.g., `connect` which is used to initiate a connection on a socket and `gethostbyname`.

<Callout client:load type="warning">
  If an application isn't using libc or is using, e.g., raw system calls, then torsocks is unable to be used and the traffic doesn't go through the Tor network.
</Callout>

If torsocks detects any communication that can't go through the Tor network, e.g., UDP traffic, then the connection will be denied. Also, if for any reason torsocks is unable to provide Tor anonymity guarantees to the application being used with it, then it forces the application to quit and stops the connection.

To simplify the use of the torsocks library a shell wrapper `torsocks` can be used which is a wrapper between the torsocks library and the application you're using. When using the wrapper the internet communication goes through the Tor network.

By default `torsocks` assumes it should connect to the Tor SOCKS proxy running at `127.0.0.1` on port `9050` which are the defaults used by the Tor daemon.

A configuration file for torsocks can be found in the `/etc/tor/torsocks.conf` file unless a different path is set for configuration file. If the configuration file cannot be read, then torsocks will use sensible defaults for most Tor installations.

##### Install Torsocks

If your client is running Debian/Ubuntu, then torsocks should already be installed after installing Tor.

However, if it isn't then you can first fetch the information about the latest versions of the packages available for your system by running the following command:

```sh:Update apt
sudo apt update
```

Then you can install torsocks by running the following command:

```sh:Debian/Ubuntu
sudo apt install -y torsocks
```

If your client is running Arch, then you can run the following command to install torsocks:

```sh:Arch
sudo pacman -S torsocks
```

##### Using Torsocks

We can now use torsocks to SSH into the node over the Tor network by running the following command:

```sh:SSH into Node using Torsocks
torsocks ssh -p <port-number> <username>@<onion-address>
```

Here `<port-number>` should be replaced with the port number you set in the `sshd_config` file on the node, `<username>` should be replaced with the `username` you set during installation, e.g., `satoshi`, and `<onion-address>` should be replaced with the onion address you generated when configuring the onion service on the node, e.g., `rtc5bqxmswgjng5yutevxiykautzo2dc4qltme5kkitjhw7kbfimrlad.onion`.

To SSH into my node over the Tor network, I would run the following command:

```sh:SSH into my Node using Torsocks
torsocks ssh -p 2222 satoshi@rtc5bqxmswgjng5yutevxiykautzo2dc4qltme5kkitjhw7kbfimrlad.onion
```

<Callout client:load type="info">
  When using SSH over Tor you may experience a lag when running commands on your node since Tor slows down the connection. If there is an established connection, then be patient when waiting for the response from the node.
</Callout>

## Vulnerabilities

🚧Under Construction!!!🚧

