---
label: Reverse Proxy
slug: en/guides/bitcoin-node/security/reverse-proxy
order: 50
---

import Callout from "@components/mdx/Callout.tsx";

# Reverse Proxy

As we progress through this guide we'll be installing software that exposes communication ports, e.g., the Electrum server and the blockchain explorer. The communication of the software we install should always be encrypted even if we only use these services within our LAN. Any device within the same network has the ability to listen into the exchanged data including highly sensitive data like passwords, so this communication should always be encrypted.

To encrypt the communication we'll be using [NGINX](https://nginx.org/en/) as a **reverse proxy** that is configured to use **Secure Sockets Layer/Transport Layer Security (SSL/TLS)**. By using NGINX as a reverse proxy with SSL/TLS enabled we'll be able encrypt communication outside of the node and route the traffic back to the internal services of the node with the data decrypted.

Before setting up NGINX as a reverse proxy using SSL/TLS we're going to discuss the following topics:

- What is a reverse proxy

- How to create an SSL/TLS certificate

- The basics of NGINX

## What is a Reverse Proxy

A **proxy server** is a server that sits between a client and the internet that provides indirect network services to the client. It can be on the user's local device or at various points between the user's device and the server we want to access on the internet which we'll refer to as the **origin server**.

A proxy server is used to intercept all client requests and provides responses from its cache or forwards the requests to the origin server. The client requests may include files or any other resource available on the origin server.

There are multiple types of proxy servers based on their purpose and functionality. Here we're going to focus on the reverse proxy server.

A reverse proxy is positioned in front of the origin server and handles processing and forwarding requests from clients. It provides an additional layer of security and performance improvements to optimize a service.

A reverse proxy works by intercepting a request from a client, performing some action on the request, then sending the request to the origin server in the network. The origin serverâ€™s response then travels back through the reverse proxy which gives the impression to clients that the proxy server handled the request on its own.

## SSL/TLS

SSL and TLS are both cryptographic protocols designed to provide communication security over a computer network by encrypting data and authenticating connections. TLS is the more recent version of SSL which fixes some security vulnerabilities in the earlier SSL versions.

The SSL/TLS certificate can be shared publicly, e.g., you can share it with the client you're using to access your node with. Public key cryptography is used when creating the certificate. The certificate contains the public key and the private key remains on the server and should be properly secured there. The public key and the corresponding private key are referred to as a key pair.

The certificate is used to perform a "handshake" between the server and the client using **asymmetric encryption**. During the handshake the public key is used for encryption and the private key is used for decryption. The asymmetric encryption uses the key pair to authenticate the identity of the server and to exchange data between them, e.g., the version of SSL/TLS being used, the **cipher suite** being used to encrypt the communication, establishing that a secure connection is in place before the data transfer begins, etc.

This exchange of data is used to generate **session keys**. The sessions keys are generated by using a key exchange algorithm, e.g., RSA or Diffie-Hellman using the key pair that was generated when creating the certificate. The session keys are then used to perform **symmetric encryption** of the communication session once the handshake is complete. The server and the client can agree upon new session keys for each communication session. This means even if an attacker identifies or steals one of the session keys from a previous session they'll be unable to decrypt the new communication session.

<Callout client:load type="tip">
  Usually, the handshake performed between the server and the client is used to authenticate the identity of the server. It is possible though to set up a handshake that also requires the client to send a certificate containing a public key to the server which is used to authenticate the identity of the client. This **two-way authentication** adds more overhead to the handshake, but it adds another layer of security since only authenticated clients will be able to establish a communication session with the server.
</Callout>

### Self-signed Certificate

A **self-signed SSL/TLS certificate** encrypts communication between the server and clients; however, the certificate isn't signed by any trusted **Certificate Authority (CA)**. A CA is a trusted third-party organization that verifies the authenticity of a server usually for a website to ensure the users are communicating with an official server and not a fake one set up to steal data.

The verification process involves generating a **Certificate Signing Request (CSR)** which is an encrypted block of text that includes various information about your server including the country code, state/region/province, locality name, organization name, organizational unit name, common name, e.g., the FQDN of the server, the email address, etc. The CSR and public key are then sent to the CA which will verify the identity and whether or not you control the domain submitted in the application.

Since we don't want to send Personal Identifiable Information (PII) about our node to a CA, and we're not planning on using a domain name with our node accessible on the **clearnet**, we're going to use a self-signed certificate. However, by using a self-signed certificate users cannot validate the identity of the server automatically.

### Creating the Certificate

To create a self-signed SSL/TLS certificate we'll be using [OpenSSL](https://www.openssl.org/) which contains a FOSS implementation of the SSL and TLS protocols as well as other cryptography standards and tools.

OpenSSL should already be installed on your node, but if it isn't here's how to install it

```sh:Install OpenSSL
sudo apt install -y openssl
```

After installing OpenSSL, we can create a self-signed SSL/TLS certificate by running the following command:

```sh:Create a Self-signed SSL/TLS Certificate
sudo openssl req -x509 -sha256 -days 3650 -newkey rsa:4096 -noenc -keyout /etc/ssl/private/nginx-self-signed.key -out /etc/ssl/certs/nginx-self-signed.crt -subj "/CN=localhost"
```

Here's what each part of the command does:

- `openssl`: This is the OpenSSL command line tool which allows you to use the various cryptography functions of OpenSSL's crypto library.

- `req`: This command primarily creates and processes CSRs in **Public Key Cryptography Standards (PKCS) #10** format. It can also be used to create and process self-signed certificates.

- `-x509`: This option signifies we want to create a new self-signed certificate instead of a CSR using the **X.509** standard as the format for the public key certificate.

- `-sha256`: This option specifies that we want to use the **SHA-256** hash function when generating the certificate.

- `-days`: This option specifies the number of days the certificate is valid for. The value should be a positive integer, and the default value is `30` days. For a self-signed certificate this value can be increased as necessary. We'll be using a value of `3650` days which is approximately 10 years.

- `-newkey`: This option specifies that we want to generate a new key to use with the certificate we're creating. The default value uses `rsa:2048`, i.e., an RSA key that has a key size of `2048` bits. We'll be using `rsa:4096`, i.e., an RSA key that has a key size of `4096`.

- `-noenc`: This option informs OpenSSL that we don't want to encrypt the private key that we'll be generating with the certificate. If this option is excluded, then you'll be required to enter the passphrase used to encrypt the private key each time the application using it restarts. We want NGINX to be able to read the file every time it restarts without our intervention which is why we're specifying this option. If you're not using OpenSSL 3.0 or a newer version, then you need to use the `-nodes` option instead.

- `-out`: This options specifies where we want to place the self-signed certificate we're creating. We'll be using the OpenSSL certicates location, i.e., `/etc/ssl/certs`, and we'll be using `nginx-self-signed.crt` for the file name of the certificate.

- `-keyout`: This option specifies where we want to place the private we generated with the self-signed certificate. We'll be using the OpenSSL private keys location, i.e., `/etc/ssl/private`, and we'll be using `nginx-self-signed.key` for the file name of the priate key.

- `-subj`: This option sets the subject of the certificate. When an argument is provided to this option it lets us non-interactively answer the certificate information prompt, i.e., it lets us set the values for the country code, state/region/province, locality name, organization name, organizational unit name, common name, the email address, etc. Any fields that are not specified in the `-subj` option will be left blank. Since we're creating a self-signed certificate that will be used on our LAN, we're going to set the common name, i.e., `CN` to be `localhost` using `-subj "/CN=localhost"`, and we can leave the other fields empty.

<Callout client:load type="warning">
  You can specify values for the others fields in the certificate information prompt by not specifying the `-subj` option and setting them interactively or by specifiying them in the `-subj` option. However, if you set these fields with PII and share the certificate with your client(s), then this information can be leaked. That is why we're only setting the `CN` field with a value of `localhost`.
</Callout>

### Verification

After creating the self-signed certificate and the private key, we can confirm the integrity of the key pair by taking the following steps:

1. First, we can verify the integrity of the private key to ensure it hasn't been tampered with.

2. Next, we can verify that the `modulus` of both the private and public key match.

3. Then, we can test the encryption with the public key from the certificate and the decryption with the private key.

4. Finally, we can confirm the integrity of a file which is signed with the private key.

#### Private Key Integrity

To verify the integrity of the private key we can run the following command:

```sh:Private Key Integrity
sudo openssl rsa -in /etc/ssl/private/nginx-self-signed.key -check -noout
```

If the private key is valid the output of the command should look similar to:

```sh:Valid Private Key Integrity Output
RSA key ok
```

If you see the output above, then the private key is valid,

<Callout client:load type="error">
  If you see output that looks similar to `RSA key error...`, then the private key failed the integrity check. This means your private key has been tampered with, and you should create a new certificate and private key.
</Callout>

#### Public and Private Key Modulus

To verify that the `modulus` of the public and private key match we can compare the **md5 checksums** of the certificate and the private key.

To get the md5 checksum for the public key you can run the following command:

```sh:Public Key md5 Checksum
openssl x509 -noout -modulus -in /etc/ssl/certs/nginx-self-signed.crt | openssl md5
```

The output should look similar to:

```sh:Public Key md5 Checksum Output
MD5(stdin)= 2147b185d577a98d8ab6fa303497d08c
```

To get the md5 checksum for the private key you can run the following command:

```sh:Private Key md5 Checksum
sudo openssl rsa -noout -modulus -in /etc/ssl/private/nginx-self-signed.key | openssl md5
```

The output should look similar to:

```sh:Private Key md5 Checksum Output
MD5(stdin)= 2147b185d577a98d8ab6fa303497d08c
```

If the md5 checksums of the public and private keys match *exactly*, then the `modulus` matches.

<Callout client:load type="error">
  If the md5 checksums don't match *exactly*, then you should recreate the certificate and the private key.
</Callout>

#### Encryption and Decryption

To perform encryption with the public key we can extract the public key from the certificate and output it to a file by running the following command:

```sh:Output Public Key to a File
openssl x509 -in /etc/ssl/certs/nginx-self-signed.crt -noout -pubkey > $HOME/nginx-self-signed.pub.crt
```

After running the above command the public key from the certificate will be output to the file `nginx-self-signed.pub.crt` in the `/home/<username>` directory where `<username>` is the username you set during the installation.

To view the public key you can run the following command:

```sh:View Public Key
cat $HOME/nginx-self-signed.pub.crt
```

The public key will look something like this:

```sh:Public Key
-----BEGIN PUBLIC KEY-----
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAnkv50W6F0M5DyhQPrSq6
12dZk1xStiCOJY5vS+VuWyXhvg/B+z/LWcjL8uBEOmLjjMi67Vi8KzSIDOX/oJYo
feB5/AtlmwK2kGJxMgixMYMp0dRwjY1NAYgXYHHCFnxLDhen2PkxHeYecEnuABIC
6DrZeuKswj0Ua9oSBH7arp2R+R+ycEPe99w0Hi33jffeBPxputp9LW6ICXewecn4
Q1RxTIgEYh3PWEitJaS2TYDo9ErWfHDInbJaOc1z2XV9lqmMipk6XvkoJA0uA6K/
0U/tGOUavKJNzAKyr2euBZmGWgjwRfWY+GWdYWFnquNA90R+qvHAz3RcqfHHipVv
KI3oGKq29UEm0sKlgr67TT+Go1KZ6P1Cck1VoTtWHFwOjQlunkbjUHcmlvN5o+vp
aKvWQrsZYIHtWyuunOvFL34afVefu+9ufFm5wmPf+FUuPpimUEDxTtNVnTilydYU
JvfOHaRWw8vhqxmzVJ67W1BxMd57fcEOs3LCVSgpNJ5bB+cZGymxDq2vuy807KjK
sP+eKcMbnZscg/apLE9aRr/K4/BEKu05xhtnCef31O5g8eT/tK2oH5EOoWP6MUGM
IxFLFTrD9KPSh2fkyI3IZe65MWieLFADoEch7RLAwBJvXq/0Es5aiTAvYH454see
7gAsWMJNBP9ITAJrO3jmHM0CAwEAAQ==
-----END PUBLIC KEY-----
```

Now that we have the public key saved to a file, we can create a test file, e.g., `test.txt` and add content to the file, e.g., `test` by running the following command:

```sh:Create test.txt File
echo "test" > $HOME/test.txt
```

After creating the test file, we can create an encrypted message by running the following command:

```sh:Create Encrypted Message
openssl pkeyutl -encrypt -in $HOME/test.txt -pubin -inkey $HOME/nginx-self-signed.pub.crt -out $HOME/cipher.txt
```

After running the above command the encrypted message will be output to the file `cipher.txt` in the `/home/<username>` directory where `<username>` is the username you set during the installation.

To decrypt the message in `cipher.txt` we can run the following command:

```sh:Decrypt Message
sudo openssl pkeyutl -decrypt -in $HOME/cipher.txt -inkey /etc/ssl/private/nginx-self-signed.key
```

If the decryption is successful, then the output of the command will be the content of the `test.txt` file:

```sh:Successful Decryption Output
test
```

<Callout client:load type="error">
  If the decrypted message doesn't match the content in the test file, then you should create a new certificate and private key since the private key has been tampered with.
</Callout>

#### Private Key Signature

To confirm the integrity of a file which is signed with the private key we can sign the `test.txt` file we previously created by running the following command:

```sh:Sign test.txt File
sudo openssl dgst -sha256 -sign /etc/ssl/private/nginx-self-signed.key -out $HOME/test.txt.sig $HOME/test.txt
```

After running the above command, the signature for the `test.txt` file will be output to the file `test.sig` in the `/home/<username>` directory where `<username>` is the username you set during the installation.

We can now verify the signed file with the public key that we previously extracted to the `nginx-self-signed.pub.crt` file by running the following command:

```sh:Verify Signature
sudo openssl dgst -sha256 -verify $HOME/nginx-self-signed.pub.crt -signature $HOME/test.txt.sig $HOME/test.txt
```

If the verification is successful, then the output of the command will look something like:

```sh:Successful Signature Verification Output
Verified OK
```

<Callout client:load type="error">
  If the signature verification isn't successful, then the output will look something like this `Verification Failure`. This means the private key has been tampered with, so you should create a new certificate and private key.
</Callout>

#### Deleting Files

After performing the verification steps above, we no longer need the files we created during the verification process.

To delete these files we can run the following command:

```sh:Delete Verification Files
rm -rf nginx-self-signed.pub.crt test.txt cipher.txt test.txt.sig
```

## NGINX

ðŸš§ Under Construction!!! ðŸš§

### Installation



### Configuration



### Test

